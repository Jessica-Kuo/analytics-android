


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Analytics</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.segment.analytics</a> ]
</div>

<h1>Coverage Summary for Class: Analytics (com.segment.analytics)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Analytics</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 285)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Analytics$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$11$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$2$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$3$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$Builder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 151)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$BundledIntegration</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Analytics$LogLevel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 107)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 543)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/**
<i>2</i>&nbsp; * The MIT License (MIT)
<i>3</i>&nbsp; *
<i>4</i>&nbsp; * Copyright (c) 2014 Segment.io, Inc.
<i>5</i>&nbsp; *
<i>6</i>&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
<i>7</i>&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
<i>8</i>&nbsp; * in the Software without restriction, including without limitation the rights
<i>9</i>&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
<i>10</i>&nbsp; * copies of the Software, and to permit persons to whom the Software is
<i>11</i>&nbsp; * furnished to do so, subject to the following conditions:
<i>12</i>&nbsp; *
<i>13</i>&nbsp; * The above copyright notice and this permission notice shall be included in all
<i>14</i>&nbsp; * copies or substantial portions of the Software.
<i>15</i>&nbsp; *
<i>16</i>&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<i>17</i>&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<i>18</i>&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
<i>19</i>&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<i>20</i>&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
<i>21</i>&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
<i>22</i>&nbsp; * SOFTWARE.
<i>23</i>&nbsp; */
<i>24</i>&nbsp;package com.segment.analytics;
<i>25</i>&nbsp;
<i>26</i>&nbsp;import static com.segment.analytics.internal.Utils.assertNotNull;
<i>27</i>&nbsp;import static com.segment.analytics.internal.Utils.buffer;
<i>28</i>&nbsp;import static com.segment.analytics.internal.Utils.closeQuietly;
<i>29</i>&nbsp;import static com.segment.analytics.internal.Utils.getInputStream;
<i>30</i>&nbsp;import static com.segment.analytics.internal.Utils.getResourceString;
<i>31</i>&nbsp;import static com.segment.analytics.internal.Utils.getSegmentSharedPreferences;
<i>32</i>&nbsp;import static com.segment.analytics.internal.Utils.hasPermission;
<i>33</i>&nbsp;import static com.segment.analytics.internal.Utils.immutableCopyOf;
<i>34</i>&nbsp;import static com.segment.analytics.internal.Utils.isNullOrEmpty;
<i>35</i>&nbsp;
<i>36</i>&nbsp;import android.Manifest;
<i>37</i>&nbsp;import android.annotation.SuppressLint;
<i>38</i>&nbsp;import android.app.Activity;
<i>39</i>&nbsp;import android.app.Application;
<i>40</i>&nbsp;import android.content.Context;
<i>41</i>&nbsp;import android.content.SharedPreferences;
<i>42</i>&nbsp;import android.content.pm.ActivityInfo;
<i>43</i>&nbsp;import android.content.pm.ApplicationInfo;
<i>44</i>&nbsp;import android.content.pm.PackageInfo;
<i>45</i>&nbsp;import android.content.pm.PackageManager;
<i>46</i>&nbsp;import android.os.Handler;
<i>47</i>&nbsp;import android.os.Looper;
<i>48</i>&nbsp;import android.os.Message;
<i>49</i>&nbsp;import androidx.annotation.NonNull;
<i>50</i>&nbsp;import androidx.annotation.Nullable;
<i>51</i>&nbsp;import androidx.lifecycle.Lifecycle;
<i>52</i>&nbsp;import androidx.lifecycle.ProcessLifecycleOwner;
<i>53</i>&nbsp;import com.segment.analytics.integrations.AliasPayload;
<i>54</i>&nbsp;import com.segment.analytics.integrations.BasePayload;
<i>55</i>&nbsp;import com.segment.analytics.integrations.GroupPayload;
<i>56</i>&nbsp;import com.segment.analytics.integrations.IdentifyPayload;
<i>57</i>&nbsp;import com.segment.analytics.integrations.Integration;
<i>58</i>&nbsp;import com.segment.analytics.integrations.Logger;
<i>59</i>&nbsp;import com.segment.analytics.integrations.ScreenPayload;
<i>60</i>&nbsp;import com.segment.analytics.integrations.TrackPayload;
<i>61</i>&nbsp;import com.segment.analytics.internal.Private;
<i>62</i>&nbsp;import com.segment.analytics.internal.Utils;
<i>63</i>&nbsp;import com.segment.analytics.internal.Utils.AnalyticsNetworkExecutorService;
<i>64</i>&nbsp;import java.io.BufferedWriter;
<i>65</i>&nbsp;import java.io.IOException;
<i>66</i>&nbsp;import java.io.OutputStreamWriter;
<i>67</i>&nbsp;import java.io.Writer;
<i>68</i>&nbsp;import java.util.ArrayList;
<i>69</i>&nbsp;import java.util.Collections;
<i>70</i>&nbsp;import java.util.HashMap;
<i>71</i>&nbsp;import java.util.LinkedHashMap;
<i>72</i>&nbsp;import java.util.List;
<i>73</i>&nbsp;import java.util.Map;
<i>74</i>&nbsp;import java.util.concurrent.Callable;
<i>75</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>76</i>&nbsp;import java.util.concurrent.CountDownLatch;
<i>77</i>&nbsp;import java.util.concurrent.ExecutionException;
<i>78</i>&nbsp;import java.util.concurrent.ExecutorService;
<i>79</i>&nbsp;import java.util.concurrent.Executors;
<i>80</i>&nbsp;import java.util.concurrent.TimeUnit;
<i>81</i>&nbsp;
<i>82</i>&nbsp;/**
<i>83</i>&nbsp; * The entry point into the Segment for Android SDK.
<i>84</i>&nbsp; *
<i>85</i>&nbsp; * &lt;p&gt;The idea is simple: one pipeline for all your data. Segment is the single hub to collect,
<i>86</i>&nbsp; * translate and route your data with the flip of a switch.
<i>87</i>&nbsp; *
<i>88</i>&nbsp; * &lt;p&gt;Analytics for Android will automatically batch events, queue them to disk, and upload it
<i>89</i>&nbsp; * periodically to Segment for you. It will also look up your project&#39;s settings (that you&#39;ve
<i>90</i>&nbsp; * configured in the web interface), specifically looking up settings for bundled integrations, and
<i>91</i>&nbsp; * then initialize them for you on the user&#39;s phone, and mapping our standardized events to formats
<i>92</i>&nbsp; * they can all understand. You only need to instrument Segment once, then flip a switch to install
<i>93</i>&nbsp; * new tools.
<i>94</i>&nbsp; *
<i>95</i>&nbsp; * &lt;p&gt;This class is the main entry point into the client API. Use {@link
<i>96</i>&nbsp; * #with(android.content.Context)} for the global singleton instance or construct your own instance
<i>97</i>&nbsp; * with {@link Builder}.
<i>98</i>&nbsp; *
<i>99</i>&nbsp; * @see &lt;a href=&quot;https://Segment/&quot;&gt;Segment&lt;/a&gt;
<i>100</i>&nbsp; */
<i>101</i>&nbsp;public class Analytics {
<i>102</i>&nbsp;
<b class="nc"><i>103</i>&nbsp;  static final Handler HANDLER =</b>
<b class="nc"><i>104</i>&nbsp;      new Handler(Looper.getMainLooper()) {</b>
<i>105</i>&nbsp;        @Override
<i>106</i>&nbsp;        public void handleMessage(Message msg) {
<b class="nc"><i>107</i>&nbsp;          throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</b>
<i>108</i>&nbsp;        }
<i>109</i>&nbsp;      };
<i>110</i>&nbsp;  @Private static final String OPT_OUT_PREFERENCE_KEY = &quot;opt-out&quot;;
<i>111</i>&nbsp;  static final String WRITE_KEY_RESOURCE_IDENTIFIER = &quot;analytics_write_key&quot;;
<b class="nc"><i>112</i>&nbsp;  static final List&lt;String&gt; INSTANCES = new ArrayList&lt;&gt;(1);</b>
<i>113</i>&nbsp;  /* This is intentional since we&#39;re only using the application context. */
<i>114</i>&nbsp;  @SuppressLint(&quot;StaticFieldLeak&quot;)
<b class="nc"><i>115</i>&nbsp;  static volatile Analytics singleton = null;</b>
<i>116</i>&nbsp;
<b class="nc"><i>117</i>&nbsp;  @Private static final Properties EMPTY_PROPERTIES = new Properties();</b>
<i>118</i>&nbsp;  private static final String VERSION_KEY = &quot;version&quot;;
<i>119</i>&nbsp;  private static final String BUILD_KEY = &quot;build&quot;;
<i>120</i>&nbsp;  private static final String TRACKED_ATTRIBUTION_KEY = &quot;tracked_attribution&quot;;
<i>121</i>&nbsp;  private static final String TRAITS_KEY = &quot;traits&quot;;
<i>122</i>&nbsp;
<i>123</i>&nbsp;  private final Application application;
<i>124</i>&nbsp;  final ExecutorService networkExecutor;
<i>125</i>&nbsp;  final Stats stats;
<i>126</i>&nbsp;  private final @NonNull List&lt;Middleware&gt; sourceMiddleware;
<i>127</i>&nbsp;  private final @NonNull Map&lt;String, List&lt;Middleware&gt;&gt; destinationMiddleware;
<i>128</i>&nbsp;  @Private final Options defaultOptions;
<i>129</i>&nbsp;  @Private final Traits.Cache traitsCache;
<i>130</i>&nbsp;  @Private final AnalyticsContext analyticsContext;
<i>131</i>&nbsp;  private final Logger logger;
<i>132</i>&nbsp;  final String tag;
<i>133</i>&nbsp;  final Client client;
<i>134</i>&nbsp;  final Cartographer cartographer;
<i>135</i>&nbsp;  private final ProjectSettings.Cache projectSettingsCache;
<i>136</i>&nbsp;  final Crypto crypto;
<i>137</i>&nbsp;  @Private final AnalyticsActivityLifecycleCallbacks activityLifecycleCallback;
<i>138</i>&nbsp;  @Private final Lifecycle lifecycle;
<i>139</i>&nbsp;  ProjectSettings projectSettings; // todo: make final (non-final for testing).
<i>140</i>&nbsp;  @Private final String writeKey;
<i>141</i>&nbsp;  final int flushQueueSize;
<i>142</i>&nbsp;  final long flushIntervalInMillis;
<i>143</i>&nbsp;  // Retrieving the advertising ID is asynchronous. This latch helps us wait to ensure the
<i>144</i>&nbsp;  // advertising ID is ready.
<i>145</i>&nbsp;  private final CountDownLatch advertisingIdLatch;
<i>146</i>&nbsp;  private final ExecutorService analyticsExecutor;
<i>147</i>&nbsp;  private final BooleanPreference optOut;
<i>148</i>&nbsp;
<b class="nc"><i>149</i>&nbsp;  final Map&lt;String, Boolean&gt; bundledIntegrations = new ConcurrentHashMap&lt;&gt;();</b>
<i>150</i>&nbsp;  private List&lt;Integration.Factory&gt; factories;
<i>151</i>&nbsp;  // todo: use lightweight map implementation.
<i>152</i>&nbsp;  private Map&lt;String, Integration&lt;?&gt;&gt; integrations;
<i>153</i>&nbsp;  volatile boolean shutdown;
<i>154</i>&nbsp;
<i>155</i>&nbsp;  @Private final boolean nanosecondTimestamps;
<i>156</i>&nbsp;
<i>157</i>&nbsp;  /**
<i>158</i>&nbsp;   * Return a reference to the global default {@link Analytics} instance.
<i>159</i>&nbsp;   *
<i>160</i>&nbsp;   * &lt;p&gt;This instance is automatically initialized with defaults that are suitable to most
<i>161</i>&nbsp;   * implementations.
<i>162</i>&nbsp;   *
<i>163</i>&nbsp;   * &lt;p&gt;If these settings do not meet the requirements of your application, you can override
<i>164</i>&nbsp;   * defaults in {@code analytics.xml}, or you can construct your own instance with full control
<i>165</i>&nbsp;   * over the configuration by using {@link Builder}.
<i>166</i>&nbsp;   *
<i>167</i>&nbsp;   * &lt;p&gt;By default, events are uploaded every 30 seconds, or every 20 events (whichever occurs
<i>168</i>&nbsp;   * first), and debugging is disabled.
<i>169</i>&nbsp;   */
<i>170</i>&nbsp;  public static Analytics with(Context context) {
<b class="nc"><i>171</i>&nbsp;    if (singleton == null) {</b>
<b class="nc"><i>172</i>&nbsp;      if (context == null) {</b>
<b class="nc"><i>173</i>&nbsp;        throw new IllegalArgumentException(&quot;Context must not be null.&quot;);</b>
<i>174</i>&nbsp;      }
<b class="nc"><i>175</i>&nbsp;      synchronized (Analytics.class) {</b>
<b class="nc"><i>176</i>&nbsp;        if (singleton == null) {</b>
<b class="nc"><i>177</i>&nbsp;          String writeKey = getResourceString(context, WRITE_KEY_RESOURCE_IDENTIFIER);</b>
<b class="nc"><i>178</i>&nbsp;          Builder builder = new Builder(context, writeKey);</b>
<i>179</i>&nbsp;
<i>180</i>&nbsp;          try {
<b class="nc"><i>181</i>&nbsp;            String packageName = context.getPackageName();</b>
<b class="nc"><i>182</i>&nbsp;            int flags = context.getPackageManager().getApplicationInfo(packageName, 0).flags;</b>
<b class="nc"><i>183</i>&nbsp;            boolean debugging = (flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;</b>
<b class="nc"><i>184</i>&nbsp;            if (debugging) {</b>
<b class="nc"><i>185</i>&nbsp;              builder.logLevel(LogLevel.INFO);</b>
<i>186</i>&nbsp;            }
<b class="nc"><i>187</i>&nbsp;          } catch (PackageManager.NameNotFoundException ignored) {</b>
<b class="nc"><i>188</i>&nbsp;          }</b>
<i>189</i>&nbsp;
<b class="nc"><i>190</i>&nbsp;          singleton = builder.build();</b>
<i>191</i>&nbsp;        }
<b class="nc"><i>192</i>&nbsp;      }</b>
<i>193</i>&nbsp;    }
<b class="nc"><i>194</i>&nbsp;    return singleton;</b>
<i>195</i>&nbsp;  }
<i>196</i>&nbsp;
<i>197</i>&nbsp;  /**
<i>198</i>&nbsp;   * Set the global instance returned from {@link #with}.
<i>199</i>&nbsp;   *
<i>200</i>&nbsp;   * &lt;p&gt;This method must be called before any calls to {@link #with} and may only be called once.
<i>201</i>&nbsp;   */
<i>202</i>&nbsp;  public static void setSingletonInstance(Analytics analytics) {
<b class="nc"><i>203</i>&nbsp;    synchronized (Analytics.class) {</b>
<b class="nc"><i>204</i>&nbsp;      if (singleton != null) {</b>
<b class="nc"><i>205</i>&nbsp;        throw new IllegalStateException(&quot;Singleton instance already exists.&quot;);</b>
<i>206</i>&nbsp;      }
<b class="nc"><i>207</i>&nbsp;      singleton = analytics;</b>
<b class="nc"><i>208</i>&nbsp;    }</b>
<i>209</i>&nbsp;  }
<i>210</i>&nbsp;
<i>211</i>&nbsp;  Analytics(
<i>212</i>&nbsp;      Application application,
<i>213</i>&nbsp;      ExecutorService networkExecutor,
<i>214</i>&nbsp;      Stats stats,
<i>215</i>&nbsp;      Traits.Cache traitsCache,
<i>216</i>&nbsp;      AnalyticsContext analyticsContext,
<i>217</i>&nbsp;      Options defaultOptions,
<i>218</i>&nbsp;      @NonNull Logger logger,
<i>219</i>&nbsp;      String tag,
<i>220</i>&nbsp;      @NonNull List&lt;Integration.Factory&gt; factories,
<i>221</i>&nbsp;      Client client,
<i>222</i>&nbsp;      Cartographer cartographer,
<i>223</i>&nbsp;      ProjectSettings.Cache projectSettingsCache,
<i>224</i>&nbsp;      String writeKey,
<i>225</i>&nbsp;      int flushQueueSize,
<i>226</i>&nbsp;      long flushIntervalInMillis,
<i>227</i>&nbsp;      final ExecutorService analyticsExecutor,
<i>228</i>&nbsp;      final boolean shouldTrackApplicationLifecycleEvents,
<i>229</i>&nbsp;      CountDownLatch advertisingIdLatch,
<i>230</i>&nbsp;      final boolean shouldRecordScreenViews,
<i>231</i>&nbsp;      final boolean trackAttributionInformation,
<i>232</i>&nbsp;      final boolean trackDeepLinks,
<i>233</i>&nbsp;      BooleanPreference optOut,
<i>234</i>&nbsp;      Crypto crypto,
<i>235</i>&nbsp;      @NonNull List&lt;Middleware&gt; sourceMiddleware,
<i>236</i>&nbsp;      @NonNull Map&lt;String, List&lt;Middleware&gt;&gt; destinationMiddleware,
<i>237</i>&nbsp;      @NonNull final ValueMap defaultProjectSettings,
<i>238</i>&nbsp;      @NonNull Lifecycle lifecycle,
<b class="nc"><i>239</i>&nbsp;      boolean nanosecondTimestamps) {</b>
<b class="nc"><i>240</i>&nbsp;    this.application = application;</b>
<b class="nc"><i>241</i>&nbsp;    this.networkExecutor = networkExecutor;</b>
<b class="nc"><i>242</i>&nbsp;    this.stats = stats;</b>
<b class="nc"><i>243</i>&nbsp;    this.traitsCache = traitsCache;</b>
<b class="nc"><i>244</i>&nbsp;    this.analyticsContext = analyticsContext;</b>
<b class="nc"><i>245</i>&nbsp;    this.defaultOptions = defaultOptions;</b>
<b class="nc"><i>246</i>&nbsp;    this.logger = logger;</b>
<b class="nc"><i>247</i>&nbsp;    this.tag = tag;</b>
<b class="nc"><i>248</i>&nbsp;    this.client = client;</b>
<b class="nc"><i>249</i>&nbsp;    this.cartographer = cartographer;</b>
<b class="nc"><i>250</i>&nbsp;    this.projectSettingsCache = projectSettingsCache;</b>
<b class="nc"><i>251</i>&nbsp;    this.writeKey = writeKey;</b>
<b class="nc"><i>252</i>&nbsp;    this.flushQueueSize = flushQueueSize;</b>
<b class="nc"><i>253</i>&nbsp;    this.flushIntervalInMillis = flushIntervalInMillis;</b>
<b class="nc"><i>254</i>&nbsp;    this.advertisingIdLatch = advertisingIdLatch;</b>
<b class="nc"><i>255</i>&nbsp;    this.optOut = optOut;</b>
<b class="nc"><i>256</i>&nbsp;    this.factories = factories;</b>
<b class="nc"><i>257</i>&nbsp;    this.analyticsExecutor = analyticsExecutor;</b>
<b class="nc"><i>258</i>&nbsp;    this.crypto = crypto;</b>
<b class="nc"><i>259</i>&nbsp;    this.sourceMiddleware = sourceMiddleware;</b>
<b class="nc"><i>260</i>&nbsp;    this.destinationMiddleware = destinationMiddleware;</b>
<b class="nc"><i>261</i>&nbsp;    this.lifecycle = lifecycle;</b>
<b class="nc"><i>262</i>&nbsp;    this.nanosecondTimestamps = nanosecondTimestamps;</b>
<i>263</i>&nbsp;
<b class="nc"><i>264</i>&nbsp;    namespaceSharedPreferences();</b>
<i>265</i>&nbsp;
<b class="nc"><i>266</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>267</i>&nbsp;        new Runnable() {</b>
<i>268</i>&nbsp;          @Override
<i>269</i>&nbsp;          public void run() {
<b class="nc"><i>270</i>&nbsp;            projectSettings = getSettings();</b>
<b class="nc"><i>271</i>&nbsp;            if (isNullOrEmpty(projectSettings)) {</b>
<i>272</i>&nbsp;              // Backup mode - Enable the Segment integration and load the provided
<i>273</i>&nbsp;              // defaultProjectSettings
<i>274</i>&nbsp;              // {
<i>275</i>&nbsp;              //   ...defaultProjectSettings
<i>276</i>&nbsp;              //   integrations: {
<i>277</i>&nbsp;              //     ...defaultProjectSettings.integrations
<i>278</i>&nbsp;              //     Segment.io: {
<i>279</i>&nbsp;              //       ...defaultProjectSettings.integrations.Segment.io
<i>280</i>&nbsp;              //       apiKey: &quot;{writeKey}&quot;
<i>281</i>&nbsp;              //     }
<i>282</i>&nbsp;              //   }
<i>283</i>&nbsp;              // }
<b class="nc"><i>284</i>&nbsp;              if (!defaultProjectSettings.containsKey(&quot;integrations&quot;)) {</b>
<b class="nc"><i>285</i>&nbsp;                defaultProjectSettings.put(&quot;integrations&quot;, new ValueMap());</b>
<i>286</i>&nbsp;              }
<b class="nc"><i>287</i>&nbsp;              if (!defaultProjectSettings.getValueMap(&quot;integrations&quot;).containsKey(&quot;Segment.io&quot;)) {</b>
<b class="nc"><i>288</i>&nbsp;                defaultProjectSettings</b>
<b class="nc"><i>289</i>&nbsp;                    .getValueMap(&quot;integrations&quot;)</b>
<b class="nc"><i>290</i>&nbsp;                    .put(&quot;Segment.io&quot;, new ValueMap());</b>
<i>291</i>&nbsp;              }
<b class="nc"><i>292</i>&nbsp;              if (!defaultProjectSettings</b>
<b class="nc"><i>293</i>&nbsp;                  .getValueMap(&quot;integrations&quot;)</b>
<b class="nc"><i>294</i>&nbsp;                  .getValueMap(&quot;Segment.io&quot;)</b>
<b class="nc"><i>295</i>&nbsp;                  .containsKey(&quot;apiKey&quot;)) {</b>
<b class="nc"><i>296</i>&nbsp;                defaultProjectSettings</b>
<b class="nc"><i>297</i>&nbsp;                    .getValueMap(&quot;integrations&quot;)</b>
<b class="nc"><i>298</i>&nbsp;                    .getValueMap(&quot;Segment.io&quot;)</b>
<b class="nc"><i>299</i>&nbsp;                    .putValue(&quot;apiKey&quot;, Analytics.this.writeKey);</b>
<i>300</i>&nbsp;              }
<b class="nc"><i>301</i>&nbsp;              projectSettings = ProjectSettings.create(defaultProjectSettings);</b>
<i>302</i>&nbsp;            }
<b class="nc"><i>303</i>&nbsp;            HANDLER.post(</b>
<b class="nc"><i>304</i>&nbsp;                new Runnable() {</b>
<i>305</i>&nbsp;                  @Override
<i>306</i>&nbsp;                  public void run() {
<b class="nc"><i>307</i>&nbsp;                    performInitializeIntegrations(projectSettings);</b>
<i>308</i>&nbsp;                  }
<i>309</i>&nbsp;                });
<i>310</i>&nbsp;          }
<i>311</i>&nbsp;        });
<i>312</i>&nbsp;
<b class="nc"><i>313</i>&nbsp;    logger.debug(&quot;Created analytics client for project with tag:%s.&quot;, tag);</b>
<i>314</i>&nbsp;
<b class="nc"><i>315</i>&nbsp;    activityLifecycleCallback =</b>
<i>316</i>&nbsp;        new AnalyticsActivityLifecycleCallbacks.Builder()
<b class="nc"><i>317</i>&nbsp;            .analytics(this)</b>
<b class="nc"><i>318</i>&nbsp;            .analyticsExecutor(analyticsExecutor)</b>
<b class="nc"><i>319</i>&nbsp;            .shouldTrackApplicationLifecycleEvents(shouldTrackApplicationLifecycleEvents)</b>
<b class="nc"><i>320</i>&nbsp;            .trackAttributionInformation(trackAttributionInformation)</b>
<b class="nc"><i>321</i>&nbsp;            .trackDeepLinks(trackDeepLinks)</b>
<b class="nc"><i>322</i>&nbsp;            .shouldRecordScreenViews(shouldRecordScreenViews)</b>
<b class="nc"><i>323</i>&nbsp;            .packageInfo(getPackageInfo(application))</b>
<b class="nc"><i>324</i>&nbsp;            .build();</b>
<i>325</i>&nbsp;
<b class="nc"><i>326</i>&nbsp;    application.registerActivityLifecycleCallbacks(activityLifecycleCallback);</b>
<b class="nc"><i>327</i>&nbsp;    lifecycle.addObserver(activityLifecycleCallback);</b>
<i>328</i>&nbsp;  }
<i>329</i>&nbsp;
<i>330</i>&nbsp;  @Private
<i>331</i>&nbsp;  void trackAttributionInformation() {
<b class="nc"><i>332</i>&nbsp;    BooleanPreference trackedAttribution =</b>
<i>333</i>&nbsp;        new BooleanPreference(
<b class="nc"><i>334</i>&nbsp;            getSegmentSharedPreferences(application, tag), TRACKED_ATTRIBUTION_KEY, false);</b>
<b class="nc"><i>335</i>&nbsp;    if (trackedAttribution.get()) {</b>
<i>336</i>&nbsp;      return;
<i>337</i>&nbsp;    }
<i>338</i>&nbsp;
<b class="nc"><i>339</i>&nbsp;    waitForAdvertisingId();</b>
<i>340</i>&nbsp;
<b class="nc"><i>341</i>&nbsp;    Client.Connection connection = null;</b>
<i>342</i>&nbsp;    try {
<b class="nc"><i>343</i>&nbsp;      connection = client.attribution();</b>
<i>344</i>&nbsp;
<i>345</i>&nbsp;      // Write the request body.
<b class="nc"><i>346</i>&nbsp;      Writer writer = new BufferedWriter(new OutputStreamWriter(connection.os));</b>
<b class="nc"><i>347</i>&nbsp;      cartographer.toJson(analyticsContext, writer);</b>
<i>348</i>&nbsp;
<i>349</i>&nbsp;      // Read the response body.
<b class="nc"><i>350</i>&nbsp;      Map&lt;String, Object&gt; map =</b>
<b class="nc"><i>351</i>&nbsp;          cartographer.fromJson(buffer(getInputStream(connection.connection)));</b>
<b class="nc"><i>352</i>&nbsp;      Properties properties = new Properties(map);</b>
<i>353</i>&nbsp;
<b class="nc"><i>354</i>&nbsp;      track(&quot;Install Attributed&quot;, properties);</b>
<b class="nc"><i>355</i>&nbsp;      trackedAttribution.set(true);</b>
<b class="nc"><i>356</i>&nbsp;    } catch (IOException e) {</b>
<b class="nc"><i>357</i>&nbsp;      logger.error(e, &quot;Unable to track attribution information. Retrying on next launch.&quot;);</b>
<i>358</i>&nbsp;    } finally {
<b class="nc"><i>359</i>&nbsp;      closeQuietly(connection);</b>
<b class="nc"><i>360</i>&nbsp;    }</b>
<i>361</i>&nbsp;  }
<i>362</i>&nbsp;
<i>363</i>&nbsp;  @Private
<i>364</i>&nbsp;  void trackApplicationLifecycleEvents() {
<i>365</i>&nbsp;    // Get the current version.
<b class="nc"><i>366</i>&nbsp;    PackageInfo packageInfo = getPackageInfo(application);</b>
<b class="nc"><i>367</i>&nbsp;    String currentVersion = packageInfo.versionName;</b>
<b class="nc"><i>368</i>&nbsp;    int currentBuild = packageInfo.versionCode;</b>
<i>369</i>&nbsp;
<i>370</i>&nbsp;    // Get the previous recorded version.
<b class="nc"><i>371</i>&nbsp;    SharedPreferences sharedPreferences = getSegmentSharedPreferences(application, tag);</b>
<b class="nc"><i>372</i>&nbsp;    String previousVersion = sharedPreferences.getString(VERSION_KEY, null);</b>
<b class="nc"><i>373</i>&nbsp;    int previousBuild = sharedPreferences.getInt(BUILD_KEY, -1);</b>
<i>374</i>&nbsp;
<i>375</i>&nbsp;    // Check and track Application Installed or Application Updated.
<b class="nc"><i>376</i>&nbsp;    if (previousBuild == -1) {</b>
<b class="nc"><i>377</i>&nbsp;      track(</b>
<i>378</i>&nbsp;          &quot;Application Installed&quot;,
<i>379</i>&nbsp;          new Properties() //
<b class="nc"><i>380</i>&nbsp;              .putValue(VERSION_KEY, currentVersion)</b>
<b class="nc"><i>381</i>&nbsp;              .putValue(BUILD_KEY, String.valueOf(currentBuild)));</b>
<b class="nc"><i>382</i>&nbsp;    } else if (currentBuild != previousBuild) {</b>
<b class="nc"><i>383</i>&nbsp;      track(</b>
<i>384</i>&nbsp;          &quot;Application Updated&quot;,
<i>385</i>&nbsp;          new Properties() //
<b class="nc"><i>386</i>&nbsp;              .putValue(VERSION_KEY, currentVersion)</b>
<b class="nc"><i>387</i>&nbsp;              .putValue(BUILD_KEY, String.valueOf(currentBuild))</b>
<b class="nc"><i>388</i>&nbsp;              .putValue(&quot;previous_&quot; + VERSION_KEY, previousVersion)</b>
<b class="nc"><i>389</i>&nbsp;              .putValue(&quot;previous_&quot; + BUILD_KEY, String.valueOf(previousBuild)));</b>
<i>390</i>&nbsp;    }
<i>391</i>&nbsp;
<i>392</i>&nbsp;    // Update the recorded version.
<b class="nc"><i>393</i>&nbsp;    SharedPreferences.Editor editor = sharedPreferences.edit();</b>
<b class="nc"><i>394</i>&nbsp;    editor.putString(VERSION_KEY, currentVersion);</b>
<b class="nc"><i>395</i>&nbsp;    editor.putInt(BUILD_KEY, currentBuild);</b>
<b class="nc"><i>396</i>&nbsp;    editor.apply();</b>
<i>397</i>&nbsp;  }
<i>398</i>&nbsp;
<i>399</i>&nbsp;  static PackageInfo getPackageInfo(Context context) {
<b class="nc"><i>400</i>&nbsp;    PackageManager packageManager = context.getPackageManager();</b>
<i>401</i>&nbsp;    try {
<b class="nc"><i>402</i>&nbsp;      return packageManager.getPackageInfo(context.getPackageName(), 0);</b>
<b class="nc"><i>403</i>&nbsp;    } catch (PackageManager.NameNotFoundException e) {</b>
<b class="nc"><i>404</i>&nbsp;      throw new AssertionError(&quot;Package not found: &quot; + context.getPackageName());</b>
<i>405</i>&nbsp;    }
<i>406</i>&nbsp;  }
<i>407</i>&nbsp;
<i>408</i>&nbsp;  @Private
<i>409</i>&nbsp;  void recordScreenViews(Activity activity) {
<b class="nc"><i>410</i>&nbsp;    PackageManager packageManager = activity.getPackageManager();</b>
<i>411</i>&nbsp;    try {
<b class="nc"><i>412</i>&nbsp;      ActivityInfo info =</b>
<b class="nc"><i>413</i>&nbsp;          packageManager.getActivityInfo(activity.getComponentName(), PackageManager.GET_META_DATA);</b>
<b class="nc"><i>414</i>&nbsp;      CharSequence activityLabel = info.loadLabel(packageManager);</b>
<b class="nc"><i>415</i>&nbsp;      screen(activityLabel.toString());</b>
<b class="nc"><i>416</i>&nbsp;    } catch (PackageManager.NameNotFoundException e) {</b>
<b class="nc"><i>417</i>&nbsp;      throw new AssertionError(&quot;Activity Not Found: &quot; + e.toString());</b>
<b class="nc"><i>418</i>&nbsp;    } catch (Exception e) {</b>
<b class="nc"><i>419</i>&nbsp;      logger.error(e, &quot;Unable to track screen view for %s&quot;, activity.toString());</b>
<b class="nc"><i>420</i>&nbsp;    }</b>
<i>421</i>&nbsp;  }
<i>422</i>&nbsp;
<i>423</i>&nbsp;  @Private
<i>424</i>&nbsp;  void runOnMainThread(final IntegrationOperation operation) {
<b class="nc"><i>425</i>&nbsp;    if (shutdown) {</b>
<i>426</i>&nbsp;      return;
<i>427</i>&nbsp;    }
<b class="nc"><i>428</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>429</i>&nbsp;        new Runnable() {</b>
<i>430</i>&nbsp;          @Override
<i>431</i>&nbsp;          public void run() {
<b class="nc"><i>432</i>&nbsp;            HANDLER.post(</b>
<b class="nc"><i>433</i>&nbsp;                new Runnable() {</b>
<i>434</i>&nbsp;                  @Override
<i>435</i>&nbsp;                  public void run() {
<b class="nc"><i>436</i>&nbsp;                    performRun(operation);</b>
<i>437</i>&nbsp;                  }
<i>438</i>&nbsp;                });
<i>439</i>&nbsp;          }
<i>440</i>&nbsp;        });
<i>441</i>&nbsp;  }
<i>442</i>&nbsp;
<i>443</i>&nbsp;  // Analytics API
<i>444</i>&nbsp;
<i>445</i>&nbsp;  /** @see #identify(String, Traits, Options) */
<i>446</i>&nbsp;  public void identify(@NonNull String userId) {
<b class="nc"><i>447</i>&nbsp;    identify(userId, null, null);</b>
<i>448</i>&nbsp;  }
<i>449</i>&nbsp;
<i>450</i>&nbsp;  /** @see #identify(String, Traits, Options) */
<i>451</i>&nbsp;  public void identify(@NonNull Traits traits) {
<b class="nc"><i>452</i>&nbsp;    identify(null, traits, null);</b>
<i>453</i>&nbsp;  }
<i>454</i>&nbsp;
<i>455</i>&nbsp;  /**
<i>456</i>&nbsp;   * Identify lets you tie one of your users and their actions to a recognizable {@code userId}. It
<i>457</i>&nbsp;   * also lets you record {@code traits} about the user, like their email, name, account type, etc.
<i>458</i>&nbsp;   *
<i>459</i>&nbsp;   * &lt;p&gt;Traits and userId will be automatically cached and available on future sessions for the same
<i>460</i>&nbsp;   * user. To update a trait on the server, call identify with the same user id (or null). You can
<i>461</i>&nbsp;   * also use {@link #identify(Traits)} for this purpose.
<i>462</i>&nbsp;   *
<i>463</i>&nbsp;   * @param userId Unique identifier which you recognize a user by in your own database. If this is
<i>464</i>&nbsp;   *     null or empty, any previous id we have (could be the anonymous id) will be used.
<i>465</i>&nbsp;   * @param newTraits Traits about the user.
<i>466</i>&nbsp;   * @param options To configure the call, these override the defaultOptions, to extend use
<i>467</i>&nbsp;   *     #getDefaultOptions()
<i>468</i>&nbsp;   * @throws IllegalArgumentException if both {@code userId} and {@code newTraits} are not provided
<i>469</i>&nbsp;   * @see &lt;a href=&quot;https://segment.com/docs/spec/identify/&quot;&gt;Identify Documentation&lt;/a&gt;
<i>470</i>&nbsp;   */
<i>471</i>&nbsp;  public void identify(
<i>472</i>&nbsp;      final @Nullable String userId,
<i>473</i>&nbsp;      final @Nullable Traits newTraits,
<i>474</i>&nbsp;      final @Nullable Options options) {
<b class="nc"><i>475</i>&nbsp;    assertNotShutdown();</b>
<b class="nc"><i>476</i>&nbsp;    if (isNullOrEmpty(userId) &amp;&amp; isNullOrEmpty(newTraits)) {</b>
<b class="nc"><i>477</i>&nbsp;      throw new IllegalArgumentException(&quot;Either userId or some traits must be provided.&quot;);</b>
<i>478</i>&nbsp;    }
<i>479</i>&nbsp;
<b class="nc"><i>480</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>481</i>&nbsp;        new Runnable() {</b>
<i>482</i>&nbsp;          @Override
<i>483</i>&nbsp;          public void run() {
<b class="nc"><i>484</i>&nbsp;            Traits traits = traitsCache.get();</b>
<b class="nc"><i>485</i>&nbsp;            if (!isNullOrEmpty(userId)) {</b>
<b class="nc"><i>486</i>&nbsp;              traits.putUserId(userId);</b>
<i>487</i>&nbsp;            }
<b class="nc"><i>488</i>&nbsp;            if (!isNullOrEmpty(newTraits)) {</b>
<b class="nc"><i>489</i>&nbsp;              traits.putAll(newTraits);</b>
<i>490</i>&nbsp;            }
<i>491</i>&nbsp;
<b class="nc"><i>492</i>&nbsp;            traitsCache.set(traits); // Save the new traits</b>
<b class="nc"><i>493</i>&nbsp;            analyticsContext.setTraits(traits); // Update the references</b>
<i>494</i>&nbsp;
<b class="nc"><i>495</i>&nbsp;            IdentifyPayload.Builder builder =</b>
<b class="nc"><i>496</i>&nbsp;                new IdentifyPayload.Builder().traits(traitsCache.get());</b>
<b class="nc"><i>497</i>&nbsp;            fillAndEnqueue(builder, options);</b>
<i>498</i>&nbsp;          }
<i>499</i>&nbsp;        });
<i>500</i>&nbsp;  }
<i>501</i>&nbsp;
<i>502</i>&nbsp;  /** @see #group(String, Traits, Options) */
<i>503</i>&nbsp;  public void group(@NonNull String groupId) {
<b class="nc"><i>504</i>&nbsp;    group(groupId, null, null);</b>
<i>505</i>&nbsp;  }
<i>506</i>&nbsp;
<i>507</i>&nbsp;  /** @see #group(String, Traits, Options) */
<i>508</i>&nbsp;  public void group(@NonNull String groupId, @Nullable Traits traits) {
<b class="nc"><i>509</i>&nbsp;    group(groupId, traits, null);</b>
<i>510</i>&nbsp;  }
<i>511</i>&nbsp;
<i>512</i>&nbsp;  /**
<i>513</i>&nbsp;   * The group method lets you associate a user with a group. It also lets you record custom traits
<i>514</i>&nbsp;   * about the group, like industry or number of employees.
<i>515</i>&nbsp;   *
<i>516</i>&nbsp;   * &lt;p&gt;If you&#39;ve called {@link #identify(String, Traits, Options)} before, this will automatically
<i>517</i>&nbsp;   * remember the userId. If not, it will fall back to use the anonymousId instead.
<i>518</i>&nbsp;   *
<i>519</i>&nbsp;   * @param groupId Unique identifier which you recognize a group by in your own database. Must not
<i>520</i>&nbsp;   *     be null or empty.
<i>521</i>&nbsp;   * @param options To configure the call, these override the defaultOptions, to extend use
<i>522</i>&nbsp;   *     #getDefaultOptions()
<i>523</i>&nbsp;   * @throws IllegalArgumentException if groupId is null or an empty string.
<i>524</i>&nbsp;   * @see &lt;a href=&quot;https://segment.com/docs/spec/group/&quot;&gt;Group Documentation&lt;/a&gt;
<i>525</i>&nbsp;   */
<i>526</i>&nbsp;  public void group(
<i>527</i>&nbsp;      @NonNull final String groupId,
<i>528</i>&nbsp;      @Nullable final Traits groupTraits,
<i>529</i>&nbsp;      @Nullable final Options options) {
<b class="nc"><i>530</i>&nbsp;    assertNotShutdown();</b>
<b class="nc"><i>531</i>&nbsp;    if (isNullOrEmpty(groupId)) {</b>
<b class="nc"><i>532</i>&nbsp;      throw new IllegalArgumentException(&quot;groupId must not be null or empty.&quot;);</b>
<i>533</i>&nbsp;    }
<i>534</i>&nbsp;
<b class="nc"><i>535</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>536</i>&nbsp;        new Runnable() {</b>
<i>537</i>&nbsp;          @Override
<i>538</i>&nbsp;          public void run() {
<i>539</i>&nbsp;            final Traits finalGroupTraits;
<b class="nc"><i>540</i>&nbsp;            if (groupTraits == null) {</b>
<b class="nc"><i>541</i>&nbsp;              finalGroupTraits = new Traits();</b>
<i>542</i>&nbsp;            } else {
<b class="nc"><i>543</i>&nbsp;              finalGroupTraits = groupTraits;</b>
<i>544</i>&nbsp;            }
<i>545</i>&nbsp;
<b class="nc"><i>546</i>&nbsp;            GroupPayload.Builder builder =</b>
<b class="nc"><i>547</i>&nbsp;                new GroupPayload.Builder().groupId(groupId).traits(finalGroupTraits);</b>
<b class="nc"><i>548</i>&nbsp;            fillAndEnqueue(builder, options);</b>
<i>549</i>&nbsp;          }
<i>550</i>&nbsp;        });
<i>551</i>&nbsp;  }
<i>552</i>&nbsp;
<i>553</i>&nbsp;  /** @see #track(String, Properties, Options) */
<i>554</i>&nbsp;  public void track(@NonNull String event) {
<b class="nc"><i>555</i>&nbsp;    track(event, null, null);</b>
<i>556</i>&nbsp;  }
<i>557</i>&nbsp;
<i>558</i>&nbsp;  /** @see #track(String, Properties, Options) */
<i>559</i>&nbsp;  public void track(@NonNull String event, @Nullable Properties properties) {
<b class="nc"><i>560</i>&nbsp;    track(event, properties, null);</b>
<i>561</i>&nbsp;  }
<i>562</i>&nbsp;
<i>563</i>&nbsp;  /**
<i>564</i>&nbsp;   * The track method is how you record any actions your users perform. Each action is known by a
<i>565</i>&nbsp;   * name, like &#39;Purchased a T-Shirt&#39;. You can also record properties specific to those actions. For
<i>566</i>&nbsp;   * example a &#39;Purchased a Shirt&#39; event might have properties like revenue or size.
<i>567</i>&nbsp;   *
<i>568</i>&nbsp;   * @param event Name of the event. Must not be null or empty.
<i>569</i>&nbsp;   * @param properties {@link Properties} to add extra information to this call.
<i>570</i>&nbsp;   * @param options To configure the call, these override the defaultOptions, to extend use
<i>571</i>&nbsp;   *     #getDefaultOptions()
<i>572</i>&nbsp;   * @throws IllegalArgumentException if event name is null or an empty string.
<i>573</i>&nbsp;   * @see &lt;a href=&quot;https://segment.com/docs/spec/track/&quot;&gt;Track Documentation&lt;/a&gt;
<i>574</i>&nbsp;   */
<i>575</i>&nbsp;  public void track(
<i>576</i>&nbsp;      final @NonNull String event,
<i>577</i>&nbsp;      final @Nullable Properties properties,
<i>578</i>&nbsp;      @Nullable final Options options) {
<b class="nc"><i>579</i>&nbsp;    assertNotShutdown();</b>
<b class="nc"><i>580</i>&nbsp;    if (isNullOrEmpty(event)) {</b>
<b class="nc"><i>581</i>&nbsp;      throw new IllegalArgumentException(&quot;event must not be null or empty.&quot;);</b>
<i>582</i>&nbsp;    }
<i>583</i>&nbsp;
<b class="nc"><i>584</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>585</i>&nbsp;        new Runnable() {</b>
<i>586</i>&nbsp;          @Override
<i>587</i>&nbsp;          public void run() {
<i>588</i>&nbsp;            final Properties finalProperties;
<b class="nc"><i>589</i>&nbsp;            if (properties == null) {</b>
<b class="nc"><i>590</i>&nbsp;              finalProperties = EMPTY_PROPERTIES;</b>
<i>591</i>&nbsp;            } else {
<b class="nc"><i>592</i>&nbsp;              finalProperties = properties;</b>
<i>593</i>&nbsp;            }
<i>594</i>&nbsp;
<b class="nc"><i>595</i>&nbsp;            TrackPayload.Builder builder =</b>
<b class="nc"><i>596</i>&nbsp;                new TrackPayload.Builder().event(event).properties(finalProperties);</b>
<b class="nc"><i>597</i>&nbsp;            fillAndEnqueue(builder, options);</b>
<i>598</i>&nbsp;          }
<i>599</i>&nbsp;        });
<i>600</i>&nbsp;  }
<i>601</i>&nbsp;
<i>602</i>&nbsp;  /**
<i>603</i>&nbsp;   * @see #screen(String, String, Properties, Options)
<i>604</i>&nbsp;   * @deprecated Use {@link #screen(String)} instead.
<i>605</i>&nbsp;   */
<i>606</i>&nbsp;  public void screen(@Nullable String category, @Nullable String name) {
<b class="nc"><i>607</i>&nbsp;    screen(category, name, null, null);</b>
<i>608</i>&nbsp;  }
<i>609</i>&nbsp;
<i>610</i>&nbsp;  /**
<i>611</i>&nbsp;   * @see #screen(String, String, Properties, Options)
<i>612</i>&nbsp;   * @deprecated Use {@link #screen(String, Properties)} instead.
<i>613</i>&nbsp;   */
<i>614</i>&nbsp;  public void screen(
<i>615</i>&nbsp;      @Nullable String category, @Nullable String name, @Nullable Properties properties) {
<b class="nc"><i>616</i>&nbsp;    screen(category, name, properties, null);</b>
<i>617</i>&nbsp;  }
<i>618</i>&nbsp;
<i>619</i>&nbsp;  /** @see #screen(String, String, Properties, Options) */
<i>620</i>&nbsp;  public void screen(@Nullable String name) {
<b class="nc"><i>621</i>&nbsp;    screen(null, name, null, null);</b>
<i>622</i>&nbsp;  }
<i>623</i>&nbsp;
<i>624</i>&nbsp;  /** @see #screen(String, String, Properties, Options) */
<i>625</i>&nbsp;  public void screen(@Nullable String name, @Nullable Properties properties) {
<b class="nc"><i>626</i>&nbsp;    screen(null, name, properties, null);</b>
<i>627</i>&nbsp;  }
<i>628</i>&nbsp;
<i>629</i>&nbsp;  /**
<i>630</i>&nbsp;   * The screen methods let your record whenever a user sees a screen of your mobile app, and attach
<i>631</i>&nbsp;   * a name, category or properties to the screen. Either category or name must be provided.
<i>632</i>&nbsp;   *
<i>633</i>&nbsp;   * @param category A category to describe the screen. Deprecated.
<i>634</i>&nbsp;   * @param name A name for the screen.
<i>635</i>&nbsp;   * @param properties {@link Properties} to add extra information to this call.
<i>636</i>&nbsp;   * @param options To configure the call, these override the defaultOptions, to extend use
<i>637</i>&nbsp;   *     #getDefaultOptions()
<i>638</i>&nbsp;   * @see &lt;a href=&quot;https://segment.com/docs/spec/screen/&quot;&gt;Screen Documentation&lt;/a&gt;
<i>639</i>&nbsp;   */
<i>640</i>&nbsp;  public void screen(
<i>641</i>&nbsp;      @Nullable final String category,
<i>642</i>&nbsp;      @Nullable final String name,
<i>643</i>&nbsp;      @Nullable final Properties properties,
<i>644</i>&nbsp;      @Nullable final Options options) {
<b class="nc"><i>645</i>&nbsp;    assertNotShutdown();</b>
<b class="nc"><i>646</i>&nbsp;    if (isNullOrEmpty(category) &amp;&amp; isNullOrEmpty(name)) {</b>
<b class="nc"><i>647</i>&nbsp;      throw new IllegalArgumentException(&quot;either category or name must be provided.&quot;);</b>
<i>648</i>&nbsp;    }
<i>649</i>&nbsp;
<b class="nc"><i>650</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>651</i>&nbsp;        new Runnable() {</b>
<i>652</i>&nbsp;          @Override
<i>653</i>&nbsp;          public void run() {
<i>654</i>&nbsp;            final Properties finalProperties;
<b class="nc"><i>655</i>&nbsp;            if (properties == null) {</b>
<b class="nc"><i>656</i>&nbsp;              finalProperties = EMPTY_PROPERTIES;</b>
<i>657</i>&nbsp;            } else {
<b class="nc"><i>658</i>&nbsp;              finalProperties = properties;</b>
<i>659</i>&nbsp;            }
<i>660</i>&nbsp;
<i>661</i>&nbsp;            //noinspection deprecation
<b class="nc"><i>662</i>&nbsp;            ScreenPayload.Builder builder =</b>
<i>663</i>&nbsp;                new ScreenPayload.Builder()
<b class="nc"><i>664</i>&nbsp;                    .name(name)</b>
<b class="nc"><i>665</i>&nbsp;                    .category(category)</b>
<b class="nc"><i>666</i>&nbsp;                    .properties(finalProperties);</b>
<b class="nc"><i>667</i>&nbsp;            fillAndEnqueue(builder, options);</b>
<i>668</i>&nbsp;          }
<i>669</i>&nbsp;        });
<i>670</i>&nbsp;  }
<i>671</i>&nbsp;
<i>672</i>&nbsp;  /** @see #alias(String, Options) */
<i>673</i>&nbsp;  public void alias(@NonNull String newId) {
<b class="nc"><i>674</i>&nbsp;    alias(newId, null);</b>
<i>675</i>&nbsp;  }
<i>676</i>&nbsp;
<i>677</i>&nbsp;  /**
<i>678</i>&nbsp;   * The alias method is used to merge two user identities, effectively connecting two sets of user
<i>679</i>&nbsp;   * data as one. This is an advanced method, but it is required to manage user identities
<i>680</i>&nbsp;   * successfully in some of our integrations.
<i>681</i>&nbsp;   *
<i>682</i>&nbsp;   * &lt;p&gt;Usage:
<i>683</i>&nbsp;   *
<i>684</i>&nbsp;   * &lt;pre&gt; &lt;code&gt;
<i>685</i>&nbsp;   *   analytics.track(&quot;user did something&quot;);
<i>686</i>&nbsp;   *   analytics.alias(newId);
<i>687</i>&nbsp;   *   analytics.identify(newId);
<i>688</i>&nbsp;   * &lt;/code&gt; &lt;/pre&gt;
<i>689</i>&nbsp;   *
<i>690</i>&nbsp;   * @param newId The new ID you want to alias the existing ID to. The existing ID will be either
<i>691</i>&nbsp;   *     the previousId if you have called identify, or the anonymous ID.
<i>692</i>&nbsp;   * @param options To configure the call, these override the defaultOptions, to extend use
<i>693</i>&nbsp;   *     #getDefaultOptions()
<i>694</i>&nbsp;   * @throws IllegalArgumentException if newId is null or empty
<i>695</i>&nbsp;   * @see &lt;a href=&quot;https://segment.com/docs/tracking-api/alias/&quot;&gt;Alias Documentation&lt;/a&gt;
<i>696</i>&nbsp;   */
<i>697</i>&nbsp;  public void alias(final @NonNull String newId, final @Nullable Options options) {
<b class="nc"><i>698</i>&nbsp;    assertNotShutdown();</b>
<b class="nc"><i>699</i>&nbsp;    if (isNullOrEmpty(newId)) {</b>
<b class="nc"><i>700</i>&nbsp;      throw new IllegalArgumentException(&quot;newId must not be null or empty.&quot;);</b>
<i>701</i>&nbsp;    }
<i>702</i>&nbsp;
<b class="nc"><i>703</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>704</i>&nbsp;        new Runnable() {</b>
<i>705</i>&nbsp;          @Override
<i>706</i>&nbsp;          public void run() {
<b class="nc"><i>707</i>&nbsp;            AliasPayload.Builder builder =</b>
<i>708</i>&nbsp;                new AliasPayload.Builder()
<b class="nc"><i>709</i>&nbsp;                    .userId(newId)</b>
<b class="nc"><i>710</i>&nbsp;                    .previousId(analyticsContext.traits().currentId());</b>
<b class="nc"><i>711</i>&nbsp;            fillAndEnqueue(builder, options);</b>
<i>712</i>&nbsp;          }
<i>713</i>&nbsp;        });
<i>714</i>&nbsp;  }
<i>715</i>&nbsp;
<i>716</i>&nbsp;  private void waitForAdvertisingId() {
<i>717</i>&nbsp;    try {
<b class="nc"><i>718</i>&nbsp;      advertisingIdLatch.await(15, TimeUnit.SECONDS);</b>
<b class="nc"><i>719</i>&nbsp;    } catch (InterruptedException e) {</b>
<b class="nc"><i>720</i>&nbsp;      logger.error(e, &quot;Thread interrupted while waiting for advertising ID.&quot;);</b>
<b class="nc"><i>721</i>&nbsp;    }</b>
<b class="nc"><i>722</i>&nbsp;    if (advertisingIdLatch.getCount() == 1) {</b>
<b class="nc"><i>723</i>&nbsp;      logger.debug(</b>
<i>724</i>&nbsp;          &quot;Advertising ID may not be collected because the API did not respond within 15 seconds.&quot;);
<i>725</i>&nbsp;    }
<i>726</i>&nbsp;  }
<i>727</i>&nbsp;
<i>728</i>&nbsp;  @Private
<i>729</i>&nbsp;  void fillAndEnqueue(BasePayload.Builder&lt;?, ?&gt; builder, Options options) {
<b class="nc"><i>730</i>&nbsp;    waitForAdvertisingId();</b>
<i>731</i>&nbsp;
<i>732</i>&nbsp;    // TODO (major version change) -&gt; do not override, merge it with defaultOptions
<i>733</i>&nbsp;    final Options finalOptions;
<b class="nc"><i>734</i>&nbsp;    if (options == null) {</b>
<b class="nc"><i>735</i>&nbsp;      finalOptions = defaultOptions;</b>
<i>736</i>&nbsp;    } else {
<b class="nc"><i>737</i>&nbsp;      finalOptions = options;</b>
<i>738</i>&nbsp;    }
<i>739</i>&nbsp;
<i>740</i>&nbsp;    // Create a new working copy
<b class="nc"><i>741</i>&nbsp;    AnalyticsContext contextCopy =</b>
<b class="nc"><i>742</i>&nbsp;        new AnalyticsContext(new LinkedHashMap&lt;&gt;(analyticsContext.size()));</b>
<b class="nc"><i>743</i>&nbsp;    contextCopy.putAll(analyticsContext);</b>
<b class="nc"><i>744</i>&nbsp;    contextCopy.putAll(finalOptions.context());</b>
<b class="nc"><i>745</i>&nbsp;    contextCopy = contextCopy.unmodifiableCopy();</b>
<i>746</i>&nbsp;
<b class="nc"><i>747</i>&nbsp;    builder.context(contextCopy);</b>
<b class="nc"><i>748</i>&nbsp;    builder.anonymousId(contextCopy.traits().anonymousId());</b>
<b class="nc"><i>749</i>&nbsp;    builder.integrations(finalOptions.integrations());</b>
<b class="nc"><i>750</i>&nbsp;    builder.nanosecondTimestamps(nanosecondTimestamps);</b>
<b class="nc"><i>751</i>&nbsp;    String cachedUserId = contextCopy.traits().userId();</b>
<b class="nc"><i>752</i>&nbsp;    if (!builder.isUserIdSet() &amp;&amp; !isNullOrEmpty(cachedUserId)) {</b>
<i>753</i>&nbsp;      // userId is not set, retrieve from cached traits and set for payload
<b class="nc"><i>754</i>&nbsp;      builder.userId(cachedUserId);</b>
<i>755</i>&nbsp;    }
<b class="nc"><i>756</i>&nbsp;    enqueue(builder.build());</b>
<i>757</i>&nbsp;  }
<i>758</i>&nbsp;
<i>759</i>&nbsp;  void enqueue(BasePayload payload) {
<b class="nc"><i>760</i>&nbsp;    if (optOut.get()) {</b>
<i>761</i>&nbsp;      return;
<i>762</i>&nbsp;    }
<b class="nc"><i>763</i>&nbsp;    logger.verbose(&quot;Created payload %s.&quot;, payload);</b>
<b class="nc"><i>764</i>&nbsp;    Middleware.Chain chain =</b>
<i>765</i>&nbsp;        new MiddlewareChainRunner(
<i>766</i>&nbsp;            0,
<i>767</i>&nbsp;            payload,
<i>768</i>&nbsp;            sourceMiddleware,
<b class="nc"><i>769</i>&nbsp;            new Middleware.Callback() {</b>
<i>770</i>&nbsp;              @Override
<i>771</i>&nbsp;              public void invoke(BasePayload payload) {
<b class="nc"><i>772</i>&nbsp;                run(payload);</b>
<i>773</i>&nbsp;              }
<i>774</i>&nbsp;            });
<b class="nc"><i>775</i>&nbsp;    chain.proceed(payload);</b>
<i>776</i>&nbsp;  }
<i>777</i>&nbsp;
<i>778</i>&nbsp;  void run(BasePayload payload) {
<b class="nc"><i>779</i>&nbsp;    logger.verbose(&quot;Running payload %s.&quot;, payload);</b>
<b class="nc"><i>780</i>&nbsp;    final IntegrationOperation operation =</b>
<b class="nc"><i>781</i>&nbsp;        IntegrationOperation.segmentEvent(payload, destinationMiddleware);</b>
<b class="nc"><i>782</i>&nbsp;    HANDLER.post(</b>
<b class="nc"><i>783</i>&nbsp;        new Runnable() {</b>
<i>784</i>&nbsp;          @Override
<i>785</i>&nbsp;          public void run() {
<b class="nc"><i>786</i>&nbsp;            performRun(operation);</b>
<i>787</i>&nbsp;          }
<i>788</i>&nbsp;        });
<i>789</i>&nbsp;  }
<i>790</i>&nbsp;
<i>791</i>&nbsp;  /**
<i>792</i>&nbsp;   * Asynchronously flushes all messages in the queue to the server, and tells bundled integrations
<i>793</i>&nbsp;   * to do the same.
<i>794</i>&nbsp;   */
<i>795</i>&nbsp;  public void flush() {
<b class="nc"><i>796</i>&nbsp;    if (shutdown) {</b>
<b class="nc"><i>797</i>&nbsp;      throw new IllegalStateException(&quot;Cannot enqueue messages after client is shutdown.&quot;);</b>
<i>798</i>&nbsp;    }
<b class="nc"><i>799</i>&nbsp;    runOnMainThread(IntegrationOperation.FLUSH);</b>
<i>800</i>&nbsp;  }
<i>801</i>&nbsp;
<i>802</i>&nbsp;  /** Get the {@link AnalyticsContext} used by this instance. */
<i>803</i>&nbsp;  @SuppressWarnings(&quot;UnusedDeclaration&quot;)
<i>804</i>&nbsp;  public AnalyticsContext getAnalyticsContext() {
<i>805</i>&nbsp;    // TODO (major version change) hide internals (don&#39;t give out working copy), expose a better API
<i>806</i>&nbsp;    //  for modifying the global context
<b class="nc"><i>807</i>&nbsp;    return analyticsContext;</b>
<i>808</i>&nbsp;  }
<i>809</i>&nbsp;
<i>810</i>&nbsp;  /** Get a copy of the default {@link Options} used by this instance */
<i>811</i>&nbsp;  public Options getDefaultOptions() {
<b class="nc"><i>812</i>&nbsp;    return new Options(defaultOptions.integrations(), defaultOptions.context());</b>
<i>813</i>&nbsp;  }
<i>814</i>&nbsp;
<i>815</i>&nbsp;  /** Creates a {@link StatsSnapshot} of the current stats for this instance. */
<i>816</i>&nbsp;  public StatsSnapshot getSnapshot() {
<b class="nc"><i>817</i>&nbsp;    return stats.createSnapshot();</b>
<i>818</i>&nbsp;  }
<i>819</i>&nbsp;
<i>820</i>&nbsp;  /** Return the {@link Application} used to create this instance. */
<i>821</i>&nbsp;  public Application getApplication() {
<b class="nc"><i>822</i>&nbsp;    return application;</b>
<i>823</i>&nbsp;  }
<i>824</i>&nbsp;
<i>825</i>&nbsp;  /**
<i>826</i>&nbsp;   * Return the {@link LogLevel} for this instance.
<i>827</i>&nbsp;   *
<i>828</i>&nbsp;   * @deprecated This will be removed in a future release.
<i>829</i>&nbsp;   */
<i>830</i>&nbsp;  @Deprecated
<i>831</i>&nbsp;  public LogLevel getLogLevel() {
<b class="nc"><i>832</i>&nbsp;    return logger.logLevel;</b>
<i>833</i>&nbsp;  }
<i>834</i>&nbsp;
<i>835</i>&nbsp;  /**
<i>836</i>&nbsp;   * Return the {@link Logger} instance used by this client.
<i>837</i>&nbsp;   *
<i>838</i>&nbsp;   * @deprecated This will be removed in a future release.
<i>839</i>&nbsp;   */
<i>840</i>&nbsp;  public Logger getLogger() {
<b class="nc"><i>841</i>&nbsp;    return logger;</b>
<i>842</i>&nbsp;  }
<i>843</i>&nbsp;
<i>844</i>&nbsp;  /** Return a new {@link Logger} with the given sub-tag. */
<i>845</i>&nbsp;  public Logger logger(String tag) {
<b class="nc"><i>846</i>&nbsp;    return logger.subLog(tag);</b>
<i>847</i>&nbsp;  }
<i>848</i>&nbsp;
<i>849</i>&nbsp;  /**
<i>850</i>&nbsp;   * Logs out the current user by clearing any information, including traits and user id.
<i>851</i>&nbsp;   *
<i>852</i>&nbsp;   * @deprecated Use {@link #reset()} instead
<i>853</i>&nbsp;   */
<i>854</i>&nbsp;  @Deprecated
<i>855</i>&nbsp;  public void logout() {
<b class="nc"><i>856</i>&nbsp;    reset();</b>
<i>857</i>&nbsp;  }
<i>858</i>&nbsp;
<i>859</i>&nbsp;  /**
<i>860</i>&nbsp;   * Resets the analytics client by clearing any stored information about the user. Events queued on
<i>861</i>&nbsp;   * disk are not cleared, and will be uploaded at a later time. Preserves BUILD and VERSION values.
<i>862</i>&nbsp;   */
<i>863</i>&nbsp;  public void reset() {
<b class="nc"><i>864</i>&nbsp;    SharedPreferences sharedPreferences = Utils.getSegmentSharedPreferences(application, tag);</b>
<i>865</i>&nbsp;    // LIB-1578: only remove traits, preserve BUILD and VERSION keys in order to to fix over-sending
<i>866</i>&nbsp;    // of &#39;Application Installed&#39; events and under-sending of &#39;Application Updated&#39; events
<b class="nc"><i>867</i>&nbsp;    SharedPreferences.Editor editor = sharedPreferences.edit();</b>
<b class="nc"><i>868</i>&nbsp;    editor.remove(TRAITS_KEY + &quot;-&quot; + tag);</b>
<b class="nc"><i>869</i>&nbsp;    editor.apply();</b>
<i>870</i>&nbsp;
<b class="nc"><i>871</i>&nbsp;    traitsCache.delete();</b>
<b class="nc"><i>872</i>&nbsp;    traitsCache.set(Traits.create());</b>
<b class="nc"><i>873</i>&nbsp;    analyticsContext.setTraits(traitsCache.get());</b>
<b class="nc"><i>874</i>&nbsp;    runOnMainThread(IntegrationOperation.RESET);</b>
<i>875</i>&nbsp;  }
<i>876</i>&nbsp;
<i>877</i>&nbsp;  /**
<i>878</i>&nbsp;   * Set the opt-out status for the current device and analytics client combination. This flag is
<i>879</i>&nbsp;   * persisted across device reboots, so you can simply call this once during your application (such
<i>880</i>&nbsp;   * as in a screen where a user can opt out of analytics tracking).
<i>881</i>&nbsp;   */
<i>882</i>&nbsp;  public void optOut(boolean optOut) {
<b class="nc"><i>883</i>&nbsp;    this.optOut.set(optOut);</b>
<i>884</i>&nbsp;  }
<i>885</i>&nbsp;
<i>886</i>&nbsp;  /**
<i>887</i>&nbsp;   * Register to be notified when a bundled integration is ready.
<i>888</i>&nbsp;   *
<i>889</i>&nbsp;   * &lt;p&gt;In most cases, integrations would have already been initialized, and the callback will be
<i>890</i>&nbsp;   * invoked fairly quickly. However there may be a latency the first time the app is launched, and
<i>891</i>&nbsp;   * we don&#39;t have settings for bundled integrations yet. This is compounded if the user is offline
<i>892</i>&nbsp;   * on the first run.
<i>893</i>&nbsp;   *
<i>894</i>&nbsp;   * &lt;p&gt;You can only register for one callback per integration at a time, and passing in a {@code
<i>895</i>&nbsp;   * callback} will remove the previous callback for that integration.
<i>896</i>&nbsp;   *
<i>897</i>&nbsp;   * &lt;p&gt;Usage:
<i>898</i>&nbsp;   *
<i>899</i>&nbsp;   * &lt;pre&gt; &lt;code&gt;
<i>900</i>&nbsp;   *   analytics.onIntegrationReady(&quot;Amplitude&quot;, new Callback() {
<i>901</i>&nbsp;   *     {@literal @}Override public void onIntegrationReady(Object instance) {
<i>902</i>&nbsp;   *       Amplitude.enableLocationListening();
<i>903</i>&nbsp;   *     }
<i>904</i>&nbsp;   *   });
<i>905</i>&nbsp;   *   analytics.onIntegrationReady(&quot;Mixpanel&quot;, new Callback&lt;&gt;() {
<i>906</i>&nbsp;   *     {@literal @}Override public void onIntegrationReady(MixpanelAPI mixpanel) {
<i>907</i>&nbsp;   *       mixpanel.clearSuperProperties();
<i>908</i>&nbsp;   *     }
<i>909</i>&nbsp;   *   })*
<i>910</i>&nbsp;   * &lt;/code&gt; &lt;/pre&gt;
<i>911</i>&nbsp;   */
<i>912</i>&nbsp;  public &lt;T&gt; void onIntegrationReady(final String key, final Callback&lt;T&gt; callback) {
<b class="nc"><i>913</i>&nbsp;    if (isNullOrEmpty(key)) {</b>
<b class="nc"><i>914</i>&nbsp;      throw new IllegalArgumentException(&quot;key cannot be null or empty.&quot;);</b>
<i>915</i>&nbsp;    }
<i>916</i>&nbsp;
<b class="nc"><i>917</i>&nbsp;    analyticsExecutor.submit(</b>
<b class="nc"><i>918</i>&nbsp;        new Runnable() {</b>
<i>919</i>&nbsp;          @Override
<i>920</i>&nbsp;          public void run() {
<b class="nc"><i>921</i>&nbsp;            HANDLER.post(</b>
<b class="nc"><i>922</i>&nbsp;                new Runnable() {</b>
<i>923</i>&nbsp;                  @Override
<i>924</i>&nbsp;                  public void run() {
<b class="nc"><i>925</i>&nbsp;                    performCallback(key, callback);</b>
<i>926</i>&nbsp;                  }
<i>927</i>&nbsp;                });
<i>928</i>&nbsp;          }
<i>929</i>&nbsp;        });
<i>930</i>&nbsp;  }
<i>931</i>&nbsp;
<i>932</i>&nbsp;  /** @deprecated Use {@link #onIntegrationReady(String, Callback)} instead. */
<i>933</i>&nbsp;  public void onIntegrationReady(
<i>934</i>&nbsp;      @SuppressWarnings(&quot;deprecation&quot;) BundledIntegration integration, Callback callback) {
<b class="nc"><i>935</i>&nbsp;    if (integration == null) {</b>
<b class="nc"><i>936</i>&nbsp;      throw new IllegalArgumentException(&quot;integration cannot be null&quot;);</b>
<i>937</i>&nbsp;    }
<b class="nc"><i>938</i>&nbsp;    onIntegrationReady(integration.key, callback);</b>
<i>939</i>&nbsp;  }
<i>940</i>&nbsp;
<i>941</i>&nbsp;  /** @deprecated */
<b class="nc"><i>942</i>&nbsp;  public enum BundledIntegration {</b>
<b class="nc"><i>943</i>&nbsp;    AMPLITUDE(&quot;Amplitude&quot;),</b>
<b class="nc"><i>944</i>&nbsp;    APPS_FLYER(&quot;AppsFlyer&quot;),</b>
<b class="nc"><i>945</i>&nbsp;    APPTIMIZE(&quot;Apptimize&quot;),</b>
<b class="nc"><i>946</i>&nbsp;    BUGSNAG(&quot;Bugsnag&quot;),</b>
<b class="nc"><i>947</i>&nbsp;    COUNTLY(&quot;Countly&quot;),</b>
<b class="nc"><i>948</i>&nbsp;    CRITTERCISM(&quot;Crittercism&quot;),</b>
<b class="nc"><i>949</i>&nbsp;    FLURRY(&quot;Flurry&quot;),</b>
<b class="nc"><i>950</i>&nbsp;    GOOGLE_ANALYTICS(&quot;Google Analytics&quot;),</b>
<b class="nc"><i>951</i>&nbsp;    KAHUNA(&quot;Kahuna&quot;),</b>
<b class="nc"><i>952</i>&nbsp;    LEANPLUM(&quot;Leanplum&quot;),</b>
<b class="nc"><i>953</i>&nbsp;    LOCALYTICS(&quot;Localytics&quot;),</b>
<b class="nc"><i>954</i>&nbsp;    MIXPANEL(&quot;Mixpanel&quot;),</b>
<b class="nc"><i>955</i>&nbsp;    QUANTCAST(&quot;Quantcast&quot;),</b>
<b class="nc"><i>956</i>&nbsp;    TAPLYTICS(&quot;Taplytics&quot;),</b>
<b class="nc"><i>957</i>&nbsp;    TAPSTREAM(&quot;Tapstream&quot;),</b>
<b class="nc"><i>958</i>&nbsp;    UXCAM(&quot;UXCam&quot;);</b>
<i>959</i>&nbsp;
<i>960</i>&nbsp;    /** The key that identifies this integration in our API. */
<i>961</i>&nbsp;    final String key;
<i>962</i>&nbsp;
<b class="nc"><i>963</i>&nbsp;    BundledIntegration(String key) {</b>
<b class="nc"><i>964</i>&nbsp;      this.key = key;</b>
<i>965</i>&nbsp;    }
<i>966</i>&nbsp;  }
<i>967</i>&nbsp;
<i>968</i>&nbsp;  /**
<i>969</i>&nbsp;   * Stops this instance from accepting further requests. In-flight events may not be uploaded right
<i>970</i>&nbsp;   * away.
<i>971</i>&nbsp;   */
<i>972</i>&nbsp;  public void shutdown() {
<b class="nc"><i>973</i>&nbsp;    if (this == singleton) {</b>
<b class="nc"><i>974</i>&nbsp;      throw new UnsupportedOperationException(&quot;Default singleton instance cannot be shutdown.&quot;);</b>
<i>975</i>&nbsp;    }
<b class="nc"><i>976</i>&nbsp;    if (shutdown) {</b>
<i>977</i>&nbsp;      return;
<i>978</i>&nbsp;    }
<b class="nc"><i>979</i>&nbsp;    application.unregisterActivityLifecycleCallbacks(activityLifecycleCallback);</b>
<b class="nc"><i>980</i>&nbsp;    lifecycle.removeObserver(activityLifecycleCallback);</b>
<i>981</i>&nbsp;    // Only supplied by us for testing, so it&#39;s ok to shut it down. If we were to make this public,
<i>982</i>&nbsp;    // we&#39;ll have to add a check similar to that of AnalyticsNetworkExecutorService below.
<b class="nc"><i>983</i>&nbsp;    analyticsExecutor.shutdown();</b>
<b class="nc"><i>984</i>&nbsp;    if (networkExecutor instanceof AnalyticsNetworkExecutorService) {</b>
<b class="nc"><i>985</i>&nbsp;      networkExecutor.shutdown();</b>
<i>986</i>&nbsp;    }
<b class="nc"><i>987</i>&nbsp;    stats.shutdown();</b>
<b class="nc"><i>988</i>&nbsp;    shutdown = true;</b>
<b class="nc"><i>989</i>&nbsp;    synchronized (INSTANCES) {</b>
<b class="nc"><i>990</i>&nbsp;      INSTANCES.remove(tag);</b>
<b class="nc"><i>991</i>&nbsp;    }</b>
<i>992</i>&nbsp;  }
<i>993</i>&nbsp;
<i>994</i>&nbsp;  private void assertNotShutdown() {
<b class="nc"><i>995</i>&nbsp;    if (shutdown) {</b>
<b class="nc"><i>996</i>&nbsp;      throw new IllegalStateException(&quot;Cannot enqueue messages after client is shutdown.&quot;);</b>
<i>997</i>&nbsp;    }
<i>998</i>&nbsp;  }
<i>999</i>&nbsp;
<i>1000</i>&nbsp;  /** Controls the level of logging. */
<b class="nc"><i>1001</i>&nbsp;  public enum LogLevel {</b>
<i>1002</i>&nbsp;    /** No logging. */
<b class="nc"><i>1003</i>&nbsp;    NONE,</b>
<i>1004</i>&nbsp;    /** Log exceptions only. */
<b class="nc"><i>1005</i>&nbsp;    INFO,</b>
<i>1006</i>&nbsp;    /** Log exceptions and print debug output. */
<b class="nc"><i>1007</i>&nbsp;    DEBUG,</b>
<i>1008</i>&nbsp;    /**
<i>1009</i>&nbsp;     * Log exceptions and print debug output.
<i>1010</i>&nbsp;     *
<i>1011</i>&nbsp;     * @deprecated Use {@link LogLevel#DEBUG} instead.
<i>1012</i>&nbsp;     */
<b class="nc"><i>1013</i>&nbsp;    @Deprecated</b>
<i>1014</i>&nbsp;    BASIC,
<i>1015</i>&nbsp;    /** Same as {@link LogLevel#DEBUG}, and log transformations in bundled integrations. */
<b class="nc"><i>1016</i>&nbsp;    VERBOSE;</b>
<i>1017</i>&nbsp;
<i>1018</i>&nbsp;    public boolean log() {
<b class="nc"><i>1019</i>&nbsp;      return this != NONE;</b>
<i>1020</i>&nbsp;    }
<i>1021</i>&nbsp;  }
<i>1022</i>&nbsp;
<i>1023</i>&nbsp;  /**
<i>1024</i>&nbsp;   * A callback interface that is invoked when the Analytics client initializes bundled
<i>1025</i>&nbsp;   * integrations.
<i>1026</i>&nbsp;   */
<i>1027</i>&nbsp;  public interface Callback&lt;T&gt; {
<i>1028</i>&nbsp;
<i>1029</i>&nbsp;    /**
<i>1030</i>&nbsp;     * This method will be invoked once for each callback.
<i>1031</i>&nbsp;     *
<i>1032</i>&nbsp;     * @param instance The underlying instance that has been initialized with the settings from
<i>1033</i>&nbsp;     *     Segment.
<i>1034</i>&nbsp;     */
<i>1035</i>&nbsp;    void onReady(T instance);
<i>1036</i>&nbsp;  }
<i>1037</i>&nbsp;
<i>1038</i>&nbsp;  /** Fluent API for creating {@link Analytics} instances. */
<i>1039</i>&nbsp;  public static class Builder {
<i>1040</i>&nbsp;
<i>1041</i>&nbsp;    private final Application application;
<i>1042</i>&nbsp;    private String writeKey;
<b class="nc"><i>1043</i>&nbsp;    private boolean collectDeviceID = Utils.DEFAULT_COLLECT_DEVICE_ID;</b>
<b class="nc"><i>1044</i>&nbsp;    private int flushQueueSize = Utils.DEFAULT_FLUSH_QUEUE_SIZE;</b>
<b class="nc"><i>1045</i>&nbsp;    private long flushIntervalInMillis = Utils.DEFAULT_FLUSH_INTERVAL;</b>
<i>1046</i>&nbsp;    private Options defaultOptions;
<i>1047</i>&nbsp;    private String tag;
<i>1048</i>&nbsp;    private LogLevel logLevel;
<i>1049</i>&nbsp;    private ExecutorService networkExecutor;
<i>1050</i>&nbsp;    private ExecutorService executor;
<i>1051</i>&nbsp;    private ConnectionFactory connectionFactory;
<b class="nc"><i>1052</i>&nbsp;    private final List&lt;Integration.Factory&gt; factories = new ArrayList&lt;&gt;();</b>
<i>1053</i>&nbsp;    private List&lt;Middleware&gt; sourceMiddleware;
<i>1054</i>&nbsp;    private Map&lt;String, List&lt;Middleware&gt;&gt; destinationMiddleware;
<b class="nc"><i>1055</i>&nbsp;    private boolean trackApplicationLifecycleEvents = false;</b>
<b class="nc"><i>1056</i>&nbsp;    private boolean recordScreenViews = false;</b>
<b class="nc"><i>1057</i>&nbsp;    private boolean trackAttributionInformation = false;</b>
<b class="nc"><i>1058</i>&nbsp;    private boolean trackDeepLinks = false;</b>
<b class="nc"><i>1059</i>&nbsp;    private boolean nanosecondTimestamps = false;</b>
<i>1060</i>&nbsp;    private Crypto crypto;
<b class="nc"><i>1061</i>&nbsp;    private ValueMap defaultProjectSettings = new ValueMap();</b>
<i>1062</i>&nbsp;
<i>1063</i>&nbsp;    /** Start building a new {@link Analytics} instance. */
<b class="nc"><i>1064</i>&nbsp;    public Builder(Context context, String writeKey) {</b>
<b class="nc"><i>1065</i>&nbsp;      if (context == null) {</b>
<b class="nc"><i>1066</i>&nbsp;        throw new IllegalArgumentException(&quot;Context must not be null.&quot;);</b>
<i>1067</i>&nbsp;      }
<b class="nc"><i>1068</i>&nbsp;      if (!hasPermission(context, Manifest.permission.INTERNET)) {</b>
<b class="nc"><i>1069</i>&nbsp;        throw new IllegalArgumentException(&quot;INTERNET permission is required.&quot;);</b>
<i>1070</i>&nbsp;      }
<b class="nc"><i>1071</i>&nbsp;      application = (Application) context.getApplicationContext();</b>
<b class="nc"><i>1072</i>&nbsp;      if (application == null) {</b>
<b class="nc"><i>1073</i>&nbsp;        throw new IllegalArgumentException(&quot;Application context must not be null.&quot;);</b>
<i>1074</i>&nbsp;      }
<i>1075</i>&nbsp;
<b class="nc"><i>1076</i>&nbsp;      if (isNullOrEmpty(writeKey)) {</b>
<b class="nc"><i>1077</i>&nbsp;        throw new IllegalArgumentException(&quot;writeKey must not be null or empty.&quot;);</b>
<i>1078</i>&nbsp;      }
<b class="nc"><i>1079</i>&nbsp;      this.writeKey = writeKey;</b>
<i>1080</i>&nbsp;    }
<i>1081</i>&nbsp;
<i>1082</i>&nbsp;    /**
<i>1083</i>&nbsp;     * Set the queue size at which the client should flush events. The client will automatically
<i>1084</i>&nbsp;     * flush events to Segment when the queue reaches {@code flushQueueSize}.
<i>1085</i>&nbsp;     *
<i>1086</i>&nbsp;     * @throws IllegalArgumentException if the flushQueueSize is less than or equal to zero.
<i>1087</i>&nbsp;     */
<i>1088</i>&nbsp;    public Builder flushQueueSize(int flushQueueSize) {
<b class="nc"><i>1089</i>&nbsp;      if (flushQueueSize &lt;= 0) {</b>
<b class="nc"><i>1090</i>&nbsp;        throw new IllegalArgumentException(&quot;flushQueueSize must be greater than or equal to zero.&quot;);</b>
<i>1091</i>&nbsp;      }
<i>1092</i>&nbsp;      // 250 is a reasonably high number to trigger queue size flushes.
<i>1093</i>&nbsp;      // The queue may go over this size (as much as 1000), but you should flush much before then.
<b class="nc"><i>1094</i>&nbsp;      if (flushQueueSize &gt; 250) {</b>
<b class="nc"><i>1095</i>&nbsp;        throw new IllegalArgumentException(&quot;flushQueueSize must be less than or equal to 250.&quot;);</b>
<i>1096</i>&nbsp;      }
<b class="nc"><i>1097</i>&nbsp;      this.flushQueueSize = flushQueueSize;</b>
<b class="nc"><i>1098</i>&nbsp;      return this;</b>
<i>1099</i>&nbsp;    }
<i>1100</i>&nbsp;
<i>1101</i>&nbsp;    /**
<i>1102</i>&nbsp;     * Set the interval at which the client should flush events. The client will automatically flush
<i>1103</i>&nbsp;     * events to Segment every {@code flushInterval} duration, regardless of {@code flushQueueSize}.
<i>1104</i>&nbsp;     *
<i>1105</i>&nbsp;     * @throws IllegalArgumentException if the flushInterval is less than or equal to zero.
<i>1106</i>&nbsp;     */
<i>1107</i>&nbsp;    public Builder flushInterval(long flushInterval, TimeUnit timeUnit) {
<b class="nc"><i>1108</i>&nbsp;      if (timeUnit == null) {</b>
<b class="nc"><i>1109</i>&nbsp;        throw new IllegalArgumentException(&quot;timeUnit must not be null.&quot;);</b>
<i>1110</i>&nbsp;      }
<b class="nc"><i>1111</i>&nbsp;      if (flushInterval &lt;= 0) {</b>
<b class="nc"><i>1112</i>&nbsp;        throw new IllegalArgumentException(&quot;flushInterval must be greater than zero.&quot;);</b>
<i>1113</i>&nbsp;      }
<b class="nc"><i>1114</i>&nbsp;      this.flushIntervalInMillis = timeUnit.toMillis(flushInterval);</b>
<b class="nc"><i>1115</i>&nbsp;      return this;</b>
<i>1116</i>&nbsp;    }
<i>1117</i>&nbsp;
<i>1118</i>&nbsp;    /**
<i>1119</i>&nbsp;     * Enable or disable collection of {@link android.provider.Settings.Secure#ANDROID_ID}, {@link
<i>1120</i>&nbsp;     * android.os.Build#SERIAL} or the Telephony Identifier retrieved via TelephonyManager as
<i>1121</i>&nbsp;     * available. Collection of the device identifier is enabled by default.
<i>1122</i>&nbsp;     */
<i>1123</i>&nbsp;    public Builder collectDeviceId(boolean collect) {
<b class="nc"><i>1124</i>&nbsp;      this.collectDeviceID = collect;</b>
<b class="nc"><i>1125</i>&nbsp;      return this;</b>
<i>1126</i>&nbsp;    }
<i>1127</i>&nbsp;
<i>1128</i>&nbsp;    /**
<i>1129</i>&nbsp;     * Set some default options for all calls. This will only be used to figure out which
<i>1130</i>&nbsp;     * integrations should be enabled or not for actions by default.
<i>1131</i>&nbsp;     *
<i>1132</i>&nbsp;     * @see Options
<i>1133</i>&nbsp;     */
<i>1134</i>&nbsp;    public Builder defaultOptions(Options defaultOptions) {
<b class="nc"><i>1135</i>&nbsp;      if (defaultOptions == null) {</b>
<b class="nc"><i>1136</i>&nbsp;        throw new IllegalArgumentException(&quot;defaultOptions must not be null.&quot;);</b>
<i>1137</i>&nbsp;      }
<i>1138</i>&nbsp;      // Make a defensive copy
<b class="nc"><i>1139</i>&nbsp;      this.defaultOptions = new Options();</b>
<b class="nc"><i>1140</i>&nbsp;      for (Map.Entry&lt;String, Object&gt; entry : defaultOptions.integrations().entrySet()) {</b>
<b class="nc"><i>1141</i>&nbsp;        if (entry.getValue() instanceof Boolean) {</b>
<b class="nc"><i>1142</i>&nbsp;          this.defaultOptions.setIntegration(entry.getKey(), (Boolean) entry.getValue());</b>
<i>1143</i>&nbsp;        } else {
<i>1144</i>&nbsp;          // A value is provided for an integration, and it is not a boolean. Assume it is enabled.
<b class="nc"><i>1145</i>&nbsp;          this.defaultOptions.setIntegration(entry.getKey(), true);</b>
<i>1146</i>&nbsp;        }
<b class="nc"><i>1147</i>&nbsp;      }</b>
<b class="nc"><i>1148</i>&nbsp;      return this;</b>
<i>1149</i>&nbsp;    }
<i>1150</i>&nbsp;
<i>1151</i>&nbsp;    /**
<i>1152</i>&nbsp;     * Set a tag for this instance. The tag is used to generate keys for caching. By default the
<i>1153</i>&nbsp;     * writeKey is used. You may want to specify an alternative one, if you want the instances with
<i>1154</i>&nbsp;     * the same writeKey to share different caches (you probably do).
<i>1155</i>&nbsp;     *
<i>1156</i>&nbsp;     * @throws IllegalArgumentException if the tag is null or empty.
<i>1157</i>&nbsp;     */
<i>1158</i>&nbsp;    public Builder tag(String tag) {
<b class="nc"><i>1159</i>&nbsp;      if (isNullOrEmpty(tag)) {</b>
<b class="nc"><i>1160</i>&nbsp;        throw new IllegalArgumentException(&quot;tag must not be null or empty.&quot;);</b>
<i>1161</i>&nbsp;      }
<b class="nc"><i>1162</i>&nbsp;      this.tag = tag;</b>
<b class="nc"><i>1163</i>&nbsp;      return this;</b>
<i>1164</i>&nbsp;    }
<i>1165</i>&nbsp;
<i>1166</i>&nbsp;    /** Set a {@link LogLevel} for this instance. */
<i>1167</i>&nbsp;    public Builder logLevel(LogLevel logLevel) {
<b class="nc"><i>1168</i>&nbsp;      if (logLevel == null) {</b>
<b class="nc"><i>1169</i>&nbsp;        throw new IllegalArgumentException(&quot;LogLevel must not be null.&quot;);</b>
<i>1170</i>&nbsp;      }
<b class="nc"><i>1171</i>&nbsp;      this.logLevel = logLevel;</b>
<b class="nc"><i>1172</i>&nbsp;      return this;</b>
<i>1173</i>&nbsp;    }
<i>1174</i>&nbsp;
<i>1175</i>&nbsp;    /** @deprecated As of {@code 3.0.1}, this method does nothing. */
<i>1176</i>&nbsp;    @Deprecated
<i>1177</i>&nbsp;    public Builder disableBundledIntegrations() {
<b class="nc"><i>1178</i>&nbsp;      return this;</b>
<i>1179</i>&nbsp;    }
<i>1180</i>&nbsp;
<i>1181</i>&nbsp;    /**
<i>1182</i>&nbsp;     * Specify the executor service for making network calls in the background.
<i>1183</i>&nbsp;     *
<i>1184</i>&nbsp;     * &lt;p&gt;Note: Calling {@link Analytics#shutdown()} will not shutdown supplied executors.
<i>1185</i>&nbsp;     *
<i>1186</i>&nbsp;     * &lt;p&gt;Use it with care! http://bit.ly/1JVlA2e
<i>1187</i>&nbsp;     */
<i>1188</i>&nbsp;    public Builder networkExecutor(ExecutorService networkExecutor) {
<b class="nc"><i>1189</i>&nbsp;      if (networkExecutor == null) {</b>
<b class="nc"><i>1190</i>&nbsp;        throw new IllegalArgumentException(&quot;Executor service must not be null.&quot;);</b>
<i>1191</i>&nbsp;      }
<b class="nc"><i>1192</i>&nbsp;      this.networkExecutor = networkExecutor;</b>
<b class="nc"><i>1193</i>&nbsp;      return this;</b>
<i>1194</i>&nbsp;    }
<i>1195</i>&nbsp;
<i>1196</i>&nbsp;    /**
<i>1197</i>&nbsp;     * Specify the connection factory for customizing how connections are created.
<i>1198</i>&nbsp;     *
<i>1199</i>&nbsp;     * &lt;p&gt;This is a beta API, and might be changed in the future. Use it with care!
<i>1200</i>&nbsp;     * http://bit.ly/1JVlA2e
<i>1201</i>&nbsp;     */
<i>1202</i>&nbsp;    public Builder connectionFactory(ConnectionFactory connectionFactory) {
<b class="nc"><i>1203</i>&nbsp;      if (connectionFactory == null) {</b>
<b class="nc"><i>1204</i>&nbsp;        throw new IllegalArgumentException(&quot;ConnectionFactory must not be null.&quot;);</b>
<i>1205</i>&nbsp;      }
<b class="nc"><i>1206</i>&nbsp;      this.connectionFactory = connectionFactory;</b>
<b class="nc"><i>1207</i>&nbsp;      return this;</b>
<i>1208</i>&nbsp;    }
<i>1209</i>&nbsp;
<i>1210</i>&nbsp;    /** Specify the crypto interface for customizing how data is stored at rest. */
<i>1211</i>&nbsp;    public Builder crypto(Crypto crypto) {
<b class="nc"><i>1212</i>&nbsp;      if (crypto == null) {</b>
<b class="nc"><i>1213</i>&nbsp;        throw new IllegalArgumentException(&quot;Crypto must not be null.&quot;);</b>
<i>1214</i>&nbsp;      }
<b class="nc"><i>1215</i>&nbsp;      this.crypto = crypto;</b>
<b class="nc"><i>1216</i>&nbsp;      return this;</b>
<i>1217</i>&nbsp;    }
<i>1218</i>&nbsp;
<i>1219</i>&nbsp;    /** TODO: docs */
<i>1220</i>&nbsp;    public Builder use(Integration.Factory factory) {
<b class="nc"><i>1221</i>&nbsp;      if (factory == null) {</b>
<b class="nc"><i>1222</i>&nbsp;        throw new IllegalArgumentException(&quot;Factory must not be null.&quot;);</b>
<i>1223</i>&nbsp;      }
<b class="nc"><i>1224</i>&nbsp;      factories.add(factory);</b>
<b class="nc"><i>1225</i>&nbsp;      return this;</b>
<i>1226</i>&nbsp;    }
<i>1227</i>&nbsp;
<i>1228</i>&nbsp;    /**
<i>1229</i>&nbsp;     * Automatically track application lifecycle events, including &quot;Application Installed&quot;,
<i>1230</i>&nbsp;     * &quot;Application Updated&quot; and &quot;Application Opened&quot;.
<i>1231</i>&nbsp;     */
<i>1232</i>&nbsp;    public Builder trackApplicationLifecycleEvents() {
<b class="nc"><i>1233</i>&nbsp;      this.trackApplicationLifecycleEvents = true;</b>
<b class="nc"><i>1234</i>&nbsp;      return this;</b>
<i>1235</i>&nbsp;    }
<i>1236</i>&nbsp;
<i>1237</i>&nbsp;    /** Automatically record screen calls when activities are created. */
<i>1238</i>&nbsp;    public Builder recordScreenViews() {
<b class="nc"><i>1239</i>&nbsp;      this.recordScreenViews = true;</b>
<b class="nc"><i>1240</i>&nbsp;      return this;</b>
<i>1241</i>&nbsp;    }
<i>1242</i>&nbsp;
<i>1243</i>&nbsp;    /** Automatically track attribution information from enabled providers. */
<i>1244</i>&nbsp;    public Builder trackAttributionInformation() {
<b class="nc"><i>1245</i>&nbsp;      this.trackAttributionInformation = true;</b>
<b class="nc"><i>1246</i>&nbsp;      return this;</b>
<i>1247</i>&nbsp;    }
<i>1248</i>&nbsp;
<i>1249</i>&nbsp;    /** Automatically track deep links as part of the screen call. */
<i>1250</i>&nbsp;    public Builder trackDeepLinks() {
<b class="nc"><i>1251</i>&nbsp;      this.trackDeepLinks = true;</b>
<b class="nc"><i>1252</i>&nbsp;      return this;</b>
<i>1253</i>&nbsp;    }
<i>1254</i>&nbsp;
<i>1255</i>&nbsp;    /**
<i>1256</i>&nbsp;     * @see #useSourceMiddleware(Middleware)
<i>1257</i>&nbsp;     * @deprecated Use {@link #useSourceMiddleware(Middleware)} instead.
<i>1258</i>&nbsp;     */
<i>1259</i>&nbsp;    public Builder middleware(Middleware middleware) {
<b class="nc"><i>1260</i>&nbsp;      return useSourceMiddleware(middleware);</b>
<i>1261</i>&nbsp;    }
<i>1262</i>&nbsp;
<i>1263</i>&nbsp;    /**
<i>1264</i>&nbsp;     * Add a {@link Middleware} custom source middleware. This will be run before sending to all
<i>1265</i>&nbsp;     * integrations
<i>1266</i>&nbsp;     */
<i>1267</i>&nbsp;    public Builder useSourceMiddleware(Middleware middleware) {
<b class="nc"><i>1268</i>&nbsp;      assertNotNull(middleware, &quot;middleware&quot;);</b>
<b class="nc"><i>1269</i>&nbsp;      if (sourceMiddleware == null) {</b>
<b class="nc"><i>1270</i>&nbsp;        sourceMiddleware = new ArrayList&lt;&gt;();</b>
<i>1271</i>&nbsp;      }
<b class="nc"><i>1272</i>&nbsp;      if (sourceMiddleware.contains(middleware)) {</b>
<b class="nc"><i>1273</i>&nbsp;        throw new IllegalStateException(&quot;Source Middleware is already registered.&quot;);</b>
<i>1274</i>&nbsp;      }
<b class="nc"><i>1275</i>&nbsp;      sourceMiddleware.add(middleware);</b>
<b class="nc"><i>1276</i>&nbsp;      return this;</b>
<i>1277</i>&nbsp;    }
<i>1278</i>&nbsp;
<i>1279</i>&nbsp;    /**
<i>1280</i>&nbsp;     * Add a {@link Middleware} custom destination middleware, for a particular destination. This
<i>1281</i>&nbsp;     * will be run before sending to the associated destination
<i>1282</i>&nbsp;     */
<i>1283</i>&nbsp;    public Builder useDestinationMiddleware(String key, Middleware middleware) {
<b class="nc"><i>1284</i>&nbsp;      if (isNullOrEmpty(key)) {</b>
<b class="nc"><i>1285</i>&nbsp;        throw new IllegalArgumentException(&quot;key must not be null or empty.&quot;);</b>
<i>1286</i>&nbsp;      }
<b class="nc"><i>1287</i>&nbsp;      assertNotNull(middleware, &quot;middleware&quot;);</b>
<b class="nc"><i>1288</i>&nbsp;      if (destinationMiddleware == null) {</b>
<b class="nc"><i>1289</i>&nbsp;        destinationMiddleware = new HashMap&lt;&gt;();</b>
<i>1290</i>&nbsp;      }
<b class="nc"><i>1291</i>&nbsp;      List&lt;Middleware&gt; middlewareList = destinationMiddleware.get(key);</b>
<b class="nc"><i>1292</i>&nbsp;      if (middlewareList == null) {</b>
<b class="nc"><i>1293</i>&nbsp;        middlewareList = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1294</i>&nbsp;        destinationMiddleware.put(key, middlewareList);</b>
<i>1295</i>&nbsp;      }
<b class="nc"><i>1296</i>&nbsp;      if (middlewareList.contains(middleware)) {</b>
<b class="nc"><i>1297</i>&nbsp;        throw new IllegalStateException(&quot;Destination Middleware is already registered.&quot;);</b>
<i>1298</i>&nbsp;      }
<b class="nc"><i>1299</i>&nbsp;      middlewareList.add(middleware);</b>
<b class="nc"><i>1300</i>&nbsp;      return this;</b>
<i>1301</i>&nbsp;    }
<i>1302</i>&nbsp;
<i>1303</i>&nbsp;    /**
<i>1304</i>&nbsp;     * Enable the use of nanoseconds timestamps for all payloads. Timestamps will be formatted as
<i>1305</i>&nbsp;     * yyyy-MM-ddThh:mm:ss.nnnnnnnnnZ Note: This is an experimental feature (and strictly opt-in)
<i>1306</i>&nbsp;     */
<i>1307</i>&nbsp;    public Builder experimentalNanosecondTimestamps() {
<b class="nc"><i>1308</i>&nbsp;      this.nanosecondTimestamps = true;</b>
<b class="nc"><i>1309</i>&nbsp;      return this;</b>
<i>1310</i>&nbsp;    }
<i>1311</i>&nbsp;
<i>1312</i>&nbsp;    /**
<i>1313</i>&nbsp;     * Set the default project settings to use, if Segment.com cannot be reached. An example
<i>1314</i>&nbsp;     * configuration can be found here, using your write key: &lt;a
<i>1315</i>&nbsp;     * href=&quot;https://cdn-settings.segment.com/v1/projects/YOUR_WRITE_KEY/settings&quot;&gt;
<i>1316</i>&nbsp;     * https://cdn-settings.segment.com/v1/projects/YOUR_WRITE_KEY/settings &lt;/a&gt;
<i>1317</i>&nbsp;     */
<i>1318</i>&nbsp;    public Builder defaultProjectSettings(ValueMap defaultProjectSettings) {
<b class="nc"><i>1319</i>&nbsp;      assertNotNull(defaultProjectSettings, &quot;defaultProjectSettings&quot;);</b>
<b class="nc"><i>1320</i>&nbsp;      this.defaultProjectSettings = defaultProjectSettings;</b>
<b class="nc"><i>1321</i>&nbsp;      return this;</b>
<i>1322</i>&nbsp;    }
<i>1323</i>&nbsp;
<i>1324</i>&nbsp;    /**
<i>1325</i>&nbsp;     * The executor on which payloads are dispatched asynchronously. This is not exposed publicly.
<i>1326</i>&nbsp;     */
<i>1327</i>&nbsp;    Builder executor(ExecutorService executor) {
<b class="nc"><i>1328</i>&nbsp;      this.executor = assertNotNull(executor, &quot;executor&quot;);</b>
<b class="nc"><i>1329</i>&nbsp;      return this;</b>
<i>1330</i>&nbsp;    }
<i>1331</i>&nbsp;
<i>1332</i>&nbsp;    /** Create a {@link Analytics} client. */
<i>1333</i>&nbsp;    public Analytics build() {
<b class="nc"><i>1334</i>&nbsp;      if (isNullOrEmpty(tag)) {</b>
<b class="nc"><i>1335</i>&nbsp;        tag = writeKey;</b>
<i>1336</i>&nbsp;      }
<b class="nc"><i>1337</i>&nbsp;      synchronized (INSTANCES) {</b>
<b class="nc"><i>1338</i>&nbsp;        if (INSTANCES.contains(tag)) {</b>
<b class="nc"><i>1339</i>&nbsp;          throw new IllegalStateException(</b>
<i>1340</i>&nbsp;              &quot;Duplicate analytics client created with tag: &quot;
<i>1341</i>&nbsp;                  + tag
<i>1342</i>&nbsp;                  + &quot;. If you want to use multiple Analytics clients, use a different writeKey &quot;
<i>1343</i>&nbsp;                  + &quot;or set a tag via the builder during construction.&quot;);
<i>1344</i>&nbsp;        }
<b class="nc"><i>1345</i>&nbsp;        INSTANCES.add(tag);</b>
<b class="nc"><i>1346</i>&nbsp;      }</b>
<i>1347</i>&nbsp;
<b class="nc"><i>1348</i>&nbsp;      if (defaultOptions == null) {</b>
<b class="nc"><i>1349</i>&nbsp;        defaultOptions = new Options();</b>
<i>1350</i>&nbsp;      }
<b class="nc"><i>1351</i>&nbsp;      if (logLevel == null) {</b>
<b class="nc"><i>1352</i>&nbsp;        logLevel = LogLevel.NONE;</b>
<i>1353</i>&nbsp;      }
<b class="nc"><i>1354</i>&nbsp;      if (networkExecutor == null) {</b>
<b class="nc"><i>1355</i>&nbsp;        networkExecutor = new AnalyticsNetworkExecutorService();</b>
<i>1356</i>&nbsp;      }
<b class="nc"><i>1357</i>&nbsp;      if (connectionFactory == null) {</b>
<b class="nc"><i>1358</i>&nbsp;        connectionFactory = new ConnectionFactory();</b>
<i>1359</i>&nbsp;      }
<b class="nc"><i>1360</i>&nbsp;      if (crypto == null) {</b>
<b class="nc"><i>1361</i>&nbsp;        crypto = Crypto.none();</b>
<i>1362</i>&nbsp;      }
<i>1363</i>&nbsp;
<b class="nc"><i>1364</i>&nbsp;      final Stats stats = new Stats();</b>
<b class="nc"><i>1365</i>&nbsp;      final Cartographer cartographer = Cartographer.INSTANCE;</b>
<b class="nc"><i>1366</i>&nbsp;      final Client client = new Client(writeKey, connectionFactory);</b>
<i>1367</i>&nbsp;
<b class="nc"><i>1368</i>&nbsp;      ProjectSettings.Cache projectSettingsCache =</b>
<i>1369</i>&nbsp;          new ProjectSettings.Cache(application, cartographer, tag);
<i>1370</i>&nbsp;
<b class="nc"><i>1371</i>&nbsp;      BooleanPreference optOut =</b>
<i>1372</i>&nbsp;          new BooleanPreference(
<b class="nc"><i>1373</i>&nbsp;              getSegmentSharedPreferences(application, tag), OPT_OUT_PREFERENCE_KEY, false);</b>
<i>1374</i>&nbsp;
<b class="nc"><i>1375</i>&nbsp;      Traits.Cache traitsCache = new Traits.Cache(application, cartographer, tag);</b>
<b class="nc"><i>1376</i>&nbsp;      if (!traitsCache.isSet() || traitsCache.get() == null) {</b>
<b class="nc"><i>1377</i>&nbsp;        Traits traits = Traits.create();</b>
<b class="nc"><i>1378</i>&nbsp;        traitsCache.set(traits);</b>
<i>1379</i>&nbsp;      }
<i>1380</i>&nbsp;
<b class="nc"><i>1381</i>&nbsp;      Logger logger = Logger.with(logLevel);</b>
<b class="nc"><i>1382</i>&nbsp;      AnalyticsContext analyticsContext =</b>
<b class="nc"><i>1383</i>&nbsp;          AnalyticsContext.create(application, traitsCache.get(), collectDeviceID);</b>
<b class="nc"><i>1384</i>&nbsp;      CountDownLatch advertisingIdLatch = new CountDownLatch(1);</b>
<b class="nc"><i>1385</i>&nbsp;      analyticsContext.attachAdvertisingId(application, advertisingIdLatch, logger);</b>
<i>1386</i>&nbsp;
<b class="nc"><i>1387</i>&nbsp;      List&lt;Integration.Factory&gt; factories = new ArrayList&lt;&gt;(1 + this.factories.size());</b>
<b class="nc"><i>1388</i>&nbsp;      factories.add(SegmentIntegration.FACTORY);</b>
<b class="nc"><i>1389</i>&nbsp;      factories.addAll(this.factories);</b>
<i>1390</i>&nbsp;
<b class="nc"><i>1391</i>&nbsp;      List&lt;Middleware&gt; srcMiddleware = Utils.immutableCopyOf(this.sourceMiddleware);</b>
<b class="nc"><i>1392</i>&nbsp;      Map&lt;String, List&lt;Middleware&gt;&gt; destMiddleware =</b>
<b class="nc"><i>1393</i>&nbsp;          isNullOrEmpty(this.destinationMiddleware)</b>
<b class="nc"><i>1394</i>&nbsp;              ? Collections.&lt;String, List&lt;Middleware&gt;&gt;emptyMap()</b>
<b class="nc"><i>1395</i>&nbsp;              : immutableCopyOf(this.destinationMiddleware);</b>
<i>1396</i>&nbsp;
<b class="nc"><i>1397</i>&nbsp;      ExecutorService executor = this.executor;</b>
<b class="nc"><i>1398</i>&nbsp;      if (executor == null) {</b>
<b class="nc"><i>1399</i>&nbsp;        executor = Executors.newSingleThreadExecutor();</b>
<i>1400</i>&nbsp;      }
<b class="nc"><i>1401</i>&nbsp;      Lifecycle lifecycle = ProcessLifecycleOwner.get().getLifecycle();</b>
<b class="nc"><i>1402</i>&nbsp;      return new Analytics(</b>
<i>1403</i>&nbsp;          application,
<i>1404</i>&nbsp;          networkExecutor,
<i>1405</i>&nbsp;          stats,
<i>1406</i>&nbsp;          traitsCache,
<i>1407</i>&nbsp;          analyticsContext,
<i>1408</i>&nbsp;          defaultOptions,
<i>1409</i>&nbsp;          logger,
<i>1410</i>&nbsp;          tag,
<b class="nc"><i>1411</i>&nbsp;          Collections.unmodifiableList(factories),</b>
<i>1412</i>&nbsp;          client,
<i>1413</i>&nbsp;          cartographer,
<i>1414</i>&nbsp;          projectSettingsCache,
<i>1415</i>&nbsp;          writeKey,
<i>1416</i>&nbsp;          flushQueueSize,
<i>1417</i>&nbsp;          flushIntervalInMillis,
<i>1418</i>&nbsp;          executor,
<i>1419</i>&nbsp;          trackApplicationLifecycleEvents,
<i>1420</i>&nbsp;          advertisingIdLatch,
<i>1421</i>&nbsp;          recordScreenViews,
<i>1422</i>&nbsp;          trackAttributionInformation,
<i>1423</i>&nbsp;          trackDeepLinks,
<i>1424</i>&nbsp;          optOut,
<i>1425</i>&nbsp;          crypto,
<i>1426</i>&nbsp;          srcMiddleware,
<i>1427</i>&nbsp;          destMiddleware,
<i>1428</i>&nbsp;          defaultProjectSettings,
<i>1429</i>&nbsp;          lifecycle,
<i>1430</i>&nbsp;          nanosecondTimestamps);
<i>1431</i>&nbsp;    }
<i>1432</i>&nbsp;  }
<i>1433</i>&nbsp;
<i>1434</i>&nbsp;  // Handler Logic.
<i>1435</i>&nbsp;  private static final long SETTINGS_REFRESH_INTERVAL = 1000 * 60 * 60 * 24; // 24 hours
<i>1436</i>&nbsp;  private static final long SETTINGS_RETRY_INTERVAL = 1000 * 60; // 1 minute
<i>1437</i>&nbsp;
<i>1438</i>&nbsp;  private ProjectSettings downloadSettings() {
<i>1439</i>&nbsp;    try {
<b class="nc"><i>1440</i>&nbsp;      ProjectSettings projectSettings =</b>
<i>1441</i>&nbsp;          networkExecutor
<b class="nc"><i>1442</i>&nbsp;              .submit(</b>
<b class="nc"><i>1443</i>&nbsp;                  new Callable&lt;ProjectSettings&gt;() {</b>
<i>1444</i>&nbsp;                    @Override
<i>1445</i>&nbsp;                    public ProjectSettings call() throws Exception {
<b class="nc"><i>1446</i>&nbsp;                      Client.Connection connection = null;</b>
<i>1447</i>&nbsp;                      try {
<b class="nc"><i>1448</i>&nbsp;                        connection = client.fetchSettings();</b>
<b class="nc"><i>1449</i>&nbsp;                        Map&lt;String, Object&gt; map = cartographer.fromJson(buffer(connection.is));</b>
<b class="nc"><i>1450</i>&nbsp;                        return ProjectSettings.create(map);</b>
<i>1451</i>&nbsp;                      } finally {
<b class="nc"><i>1452</i>&nbsp;                        closeQuietly(connection);</b>
<b class="nc"><i>1453</i>&nbsp;                      }</b>
<i>1454</i>&nbsp;                    }
<i>1455</i>&nbsp;                  })
<b class="nc"><i>1456</i>&nbsp;              .get();</b>
<b class="nc"><i>1457</i>&nbsp;      projectSettingsCache.set(projectSettings);</b>
<b class="nc"><i>1458</i>&nbsp;      return projectSettings;</b>
<b class="nc"><i>1459</i>&nbsp;    } catch (InterruptedException e) {</b>
<b class="nc"><i>1460</i>&nbsp;      logger.error(e, &quot;Thread interrupted while fetching settings.&quot;);</b>
<b class="nc"><i>1461</i>&nbsp;    } catch (ExecutionException e) {</b>
<b class="nc"><i>1462</i>&nbsp;      logger.error(e, &quot;Unable to fetch settings. Retrying in %s ms.&quot;, SETTINGS_RETRY_INTERVAL);</b>
<b class="nc"><i>1463</i>&nbsp;    }</b>
<b class="nc"><i>1464</i>&nbsp;    return null;</b>
<i>1465</i>&nbsp;  }
<i>1466</i>&nbsp;
<i>1467</i>&nbsp;  /**
<i>1468</i>&nbsp;   * Retrieve settings from the cache or the network: 1. If the cache is empty, fetch new settings.
<i>1469</i>&nbsp;   * 2. If the cache is not stale, use it. 2. If the cache is stale, try to get new settings.
<i>1470</i>&nbsp;   */
<i>1471</i>&nbsp;  @Private
<i>1472</i>&nbsp;  ProjectSettings getSettings() {
<b class="nc"><i>1473</i>&nbsp;    ProjectSettings cachedSettings = projectSettingsCache.get();</b>
<b class="nc"><i>1474</i>&nbsp;    if (isNullOrEmpty(cachedSettings)) {</b>
<b class="nc"><i>1475</i>&nbsp;      return downloadSettings();</b>
<i>1476</i>&nbsp;    }
<i>1477</i>&nbsp;
<b class="nc"><i>1478</i>&nbsp;    long expirationTime = cachedSettings.timestamp() + SETTINGS_REFRESH_INTERVAL;</b>
<b class="nc"><i>1479</i>&nbsp;    if (expirationTime &gt; System.currentTimeMillis()) {</b>
<b class="nc"><i>1480</i>&nbsp;      return cachedSettings;</b>
<i>1481</i>&nbsp;    }
<i>1482</i>&nbsp;
<b class="nc"><i>1483</i>&nbsp;    ProjectSettings downloadedSettings = downloadSettings();</b>
<b class="nc"><i>1484</i>&nbsp;    if (isNullOrEmpty(downloadedSettings)) {</b>
<b class="nc"><i>1485</i>&nbsp;      return cachedSettings;</b>
<i>1486</i>&nbsp;    }
<b class="nc"><i>1487</i>&nbsp;    return downloadedSettings;</b>
<i>1488</i>&nbsp;  }
<i>1489</i>&nbsp;
<i>1490</i>&nbsp;  void performInitializeIntegrations(ProjectSettings projectSettings) throws AssertionError {
<b class="nc"><i>1491</i>&nbsp;    if (isNullOrEmpty(projectSettings)) {</b>
<b class="nc"><i>1492</i>&nbsp;      throw new AssertionError(&quot;ProjectSettings is empty!&quot;);</b>
<i>1493</i>&nbsp;    }
<b class="nc"><i>1494</i>&nbsp;    ValueMap integrationSettings = projectSettings.integrations();</b>
<i>1495</i>&nbsp;
<b class="nc"><i>1496</i>&nbsp;    integrations = new LinkedHashMap&lt;&gt;(factories.size());</b>
<b class="nc"><i>1497</i>&nbsp;    for (int i = 0; i &lt; factories.size(); i++) {</b>
<b class="nc"><i>1498</i>&nbsp;      if (isNullOrEmpty(integrationSettings)) {</b>
<b class="nc"><i>1499</i>&nbsp;        logger.debug(&quot;Integration settings are empty&quot;);</b>
<b class="nc"><i>1500</i>&nbsp;        continue;</b>
<i>1501</i>&nbsp;      }
<b class="nc"><i>1502</i>&nbsp;      Integration.Factory factory = factories.get(i);</b>
<b class="nc"><i>1503</i>&nbsp;      String key = factory.key();</b>
<b class="nc"><i>1504</i>&nbsp;      if (isNullOrEmpty(key)) {</b>
<b class="nc"><i>1505</i>&nbsp;        throw new AssertionError(&quot;The factory key is empty!&quot;);</b>
<i>1506</i>&nbsp;      }
<b class="nc"><i>1507</i>&nbsp;      ValueMap settings = integrationSettings.getValueMap(key);</b>
<b class="nc"><i>1508</i>&nbsp;      if (isNullOrEmpty(settings)) {</b>
<b class="nc"><i>1509</i>&nbsp;        logger.debug(&quot;Integration %s is not enabled.&quot;, key);</b>
<b class="nc"><i>1510</i>&nbsp;        continue;</b>
<i>1511</i>&nbsp;      }
<b class="nc"><i>1512</i>&nbsp;      Integration integration = factory.create(settings, this);</b>
<b class="nc"><i>1513</i>&nbsp;      if (integration == null) {</b>
<b class="nc"><i>1514</i>&nbsp;        logger.info(&quot;Factory %s couldn&#39;t create integration.&quot;, factory);</b>
<i>1515</i>&nbsp;      } else {
<b class="nc"><i>1516</i>&nbsp;        integrations.put(key, integration);</b>
<b class="nc"><i>1517</i>&nbsp;        bundledIntegrations.put(key, false);</b>
<i>1518</i>&nbsp;      }
<i>1519</i>&nbsp;    }
<b class="nc"><i>1520</i>&nbsp;    factories = null;</b>
<i>1521</i>&nbsp;  }
<i>1522</i>&nbsp;
<i>1523</i>&nbsp;  /** Runs the given operation on all integrations. */
<i>1524</i>&nbsp;  void performRun(IntegrationOperation operation) {
<b class="nc"><i>1525</i>&nbsp;    for (Map.Entry&lt;String, Integration&lt;?&gt;&gt; entry : integrations.entrySet()) {</b>
<b class="nc"><i>1526</i>&nbsp;      String key = entry.getKey();</b>
<b class="nc"><i>1527</i>&nbsp;      long startTime = System.nanoTime();</b>
<b class="nc"><i>1528</i>&nbsp;      operation.run(key, entry.getValue(), projectSettings);</b>
<b class="nc"><i>1529</i>&nbsp;      long endTime = System.nanoTime();</b>
<b class="nc"><i>1530</i>&nbsp;      long durationInMillis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</b>
<b class="nc"><i>1531</i>&nbsp;      stats.dispatchIntegrationOperation(key, durationInMillis);</b>
<b class="nc"><i>1532</i>&nbsp;      logger.debug(&quot;Ran %s on integration %s in %d ns.&quot;, operation, key, endTime - startTime);</b>
<b class="nc"><i>1533</i>&nbsp;    }</b>
<i>1534</i>&nbsp;  }
<i>1535</i>&nbsp;
<i>1536</i>&nbsp;  @Private
<i>1537</i>&nbsp;  &lt;T&gt; void performCallback(String key, Callback&lt;T&gt; callback) {
<b class="nc"><i>1538</i>&nbsp;    for (Map.Entry&lt;String, Integration&lt;?&gt;&gt; entry : integrations.entrySet()) {</b>
<b class="nc"><i>1539</i>&nbsp;      if (key.equals(entry.getKey())) {</b>
<b class="nc"><i>1540</i>&nbsp;        callback.onReady((T) entry.getValue().getUnderlyingInstance());</b>
<i>1541</i>&nbsp;        return;
<i>1542</i>&nbsp;      }
<b class="nc"><i>1543</i>&nbsp;    }</b>
<i>1544</i>&nbsp;  }
<i>1545</i>&nbsp;
<i>1546</i>&nbsp;  /**
<i>1547</i>&nbsp;   * Previously (until version 4.1.7) shared preferences were not namespaced by a tag. This meant
<i>1548</i>&nbsp;   * that all analytics instances shared the same shared preferences. This migration checks if the
<i>1549</i>&nbsp;   * namespaced shared preferences instance contains {@code namespaceSharedPreferences: true}. If it
<i>1550</i>&nbsp;   * does, the migration is already run and does not need to be run again. If it doesn&#39;t, it copies
<i>1551</i>&nbsp;   * the legacy shared preferences mapping into the namespaced shared preferences, and sets
<i>1552</i>&nbsp;   * namespaceSharedPreferences to false.
<i>1553</i>&nbsp;   */
<i>1554</i>&nbsp;  private void namespaceSharedPreferences() {
<b class="nc"><i>1555</i>&nbsp;    SharedPreferences newSharedPreferences = Utils.getSegmentSharedPreferences(application, tag);</b>
<b class="nc"><i>1556</i>&nbsp;    BooleanPreference namespaceSharedPreferences =</b>
<i>1557</i>&nbsp;        new BooleanPreference(newSharedPreferences, &quot;namespaceSharedPreferences&quot;, true);
<i>1558</i>&nbsp;
<b class="nc"><i>1559</i>&nbsp;    if (namespaceSharedPreferences.get()) {</b>
<b class="nc"><i>1560</i>&nbsp;      SharedPreferences legacySharedPreferences =</b>
<b class="nc"><i>1561</i>&nbsp;          application.getSharedPreferences(&quot;analytics-android&quot;, Context.MODE_PRIVATE);</b>
<b class="nc"><i>1562</i>&nbsp;      Utils.copySharedPreferences(legacySharedPreferences, newSharedPreferences);</b>
<b class="nc"><i>1563</i>&nbsp;      namespaceSharedPreferences.set(false);</b>
<i>1564</i>&nbsp;    }
<i>1565</i>&nbsp;  }
<i>1566</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-07-24 19:51</div>
</div>
</body>
</html>
